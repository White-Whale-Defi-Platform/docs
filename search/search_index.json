{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Home Welcome to the White Whale Protocol's documentation site. You can access the White Whale platform through the official Web App . What is White Whale? White Whale is an arbitrage protocol devoted to maintaining the peg on Terra stablecoins and allowing the community to contribute in helping to achieve this misson. Deposited tokens are represented by vault tokens (vUST, vLUNA, ...). These tokens are redeemable for the initial deposit along with it's accrued interest, making these tokens auto-compouning. White Whale vaults are structured to provide depositors with: High, stable deposit yields powered by the Anchor Protocol Arbitrage Exposure through White Whale abitrage of stablecoin deposits White Whale is an open, permissionless arbitrage protocol, meaning that any third-party application is free to connect and earn interest without restrictions. Furthermore, all arbitrage contracts are publicly callable. Further documentation of White Whale Protocol is provided in the following pages. Sections Learn more about White Whale Protocol, its core smart contracts, and Python SDK. Learn more about the Governance . Read up on the specifics of each contract such as the Stablecoin Vault . Check out the User Guide . Community Twitter Github","title":"Home"},{"location":"#home","text":"Welcome to the White Whale Protocol's documentation site. You can access the White Whale platform through the official Web App .","title":"Home"},{"location":"#what-is-white-whale","text":"White Whale is an arbitrage protocol devoted to maintaining the peg on Terra stablecoins and allowing the community to contribute in helping to achieve this misson. Deposited tokens are represented by vault tokens (vUST, vLUNA, ...). These tokens are redeemable for the initial deposit along with it's accrued interest, making these tokens auto-compouning. White Whale vaults are structured to provide depositors with: High, stable deposit yields powered by the Anchor Protocol Arbitrage Exposure through White Whale abitrage of stablecoin deposits White Whale is an open, permissionless arbitrage protocol, meaning that any third-party application is free to connect and earn interest without restrictions. Furthermore, all arbitrage contracts are publicly callable. Further documentation of White Whale Protocol is provided in the following pages.","title":"What is White Whale?"},{"location":"#sections","text":"Learn more about White Whale Protocol, its core smart contracts, and Python SDK. Learn more about the Governance . Read up on the specifics of each contract such as the Stablecoin Vault . Check out the User Guide .","title":"Sections"},{"location":"#community","text":"Twitter Github","title":"Community"},{"location":"Developers-SDKS/White-Whale-Python-SDK/","text":"White Whale Python SDK The WhiteWhale Python SDK allows applications with Python runtimes to interact with White Whale Protocol. It supports easy fabrication of messages relevant to Terra-side White Whale smart contracts, used to make contract calls or query contract states. It also includes helper classes for development and instantiation of contracts. This section only provides a brief overview of the project. For additional information, please refer to the White Whale Python SDK repository .","title":"White Whale Python SDK"},{"location":"Developers-SDKS/White-Whale-Python-SDK/#white-whale-python-sdk","text":"The WhiteWhale Python SDK allows applications with Python runtimes to interact with White Whale Protocol. It supports easy fabrication of messages relevant to Terra-side White Whale smart contracts, used to make contract calls or query contract states. It also includes helper classes for development and instantiation of contracts. This section only provides a brief overview of the project. For additional information, please refer to the White Whale Python SDK repository .","title":"White Whale Python SDK"},{"location":"Smart-Contracts/Community-Fund/","text":"Community The Community fund contract holds the funds of the Community Fund , which can be spent through governance polls. It also has control over the protocol owned liquidity. It is controlled by the governance contract and serves to both grow its holdings and give grants to proposals submitted by community members. Config Name Type Description whale_token_addr CanonicalAddr Contract address of Whale Token InstantiateMsg #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] pub struct InstantiateMsg { pub whale_token_addr: String, } { \"whale_token_addr\": \"terra1...\", } Name Type Description whale_token_addr CanonicalAddr Contract address of Whale Token ExecuteMsg SetAdmin Updates the Community fund contract admin. Note: The AdminResponse object is imported from the cw_controllers package. This definition may change as that package is updated #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { SetAdmin { admin: String, } } { \"update_admin\": { \"admin\": \"terra1...\" } } Name Type Description admin String Address of the new contract admin Spend Transfers WHALE tokens to the grant recipient. Can only be issued by the the registered admin which is intended to be the Governance contract. The Spend function enables the Community Fund to provide grants to community members and on objectives defined and voted on through governance. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { Spend { recipient: String, amount: Uint128, } } { \"spend\": { \"recipient\": \"terra1...\", \"amount\": \"100000000\" } } Name Type Description recipient String Recipient of community grant amount Uint128 Community grant amount Burn Burns a specified amount of WHALE tokens. Can only be issued by the the registered admin which is intended to be the Governance contract. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { Burn { amount: Uint128, } } { \"burn\": { \"amount\": \"100000000\" } } Name Type Description amount Uint128 Amount of WHALE to burn QueryMsg Config Gets the Community Fund contract configuration. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { Config {} } { \"config\": {} } Name Type Description ConfigResponse #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] pub struct ConfigResponse { pub token_addr: Addr, } { \"token_addr\": \"terra1...\", } Name Type Description token_addr CanonicalAddr Contract address of Whale Token Admin Gets the Community Fund contract registered Admin. On launch and thereafter this should be the Governance contract. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { Admin {} } { \"admin\": {} } Name Type Description AdminResponse Note: The AdminResponse object is imported from the cw_controllers package. This definition may change as that package is updated #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema, Debug)] pub struct AdminResponse { pub admin: Option<String>, } { \"admin\": \"terra1...\", } Name Type Description admin CanonicalAddr Contract address of registered Admin of the contract","title":"Community"},{"location":"Smart-Contracts/Community-Fund/#community","text":"The Community fund contract holds the funds of the Community Fund , which can be spent through governance polls. It also has control over the protocol owned liquidity. It is controlled by the governance contract and serves to both grow its holdings and give grants to proposals submitted by community members.","title":"Community"},{"location":"Smart-Contracts/Community-Fund/#config","text":"Name Type Description whale_token_addr CanonicalAddr Contract address of Whale Token","title":"Config"},{"location":"Smart-Contracts/Community-Fund/#instantiatemsg","text":"#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] pub struct InstantiateMsg { pub whale_token_addr: String, } { \"whale_token_addr\": \"terra1...\", } Name Type Description whale_token_addr CanonicalAddr Contract address of Whale Token","title":"InstantiateMsg"},{"location":"Smart-Contracts/Community-Fund/#executemsg","text":"","title":"ExecuteMsg"},{"location":"Smart-Contracts/Community-Fund/#setadmin","text":"Updates the Community fund contract admin. Note: The AdminResponse object is imported from the cw_controllers package. This definition may change as that package is updated #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { SetAdmin { admin: String, } } { \"update_admin\": { \"admin\": \"terra1...\" } } Name Type Description admin String Address of the new contract admin","title":"SetAdmin"},{"location":"Smart-Contracts/Community-Fund/#spend","text":"Transfers WHALE tokens to the grant recipient. Can only be issued by the the registered admin which is intended to be the Governance contract. The Spend function enables the Community Fund to provide grants to community members and on objectives defined and voted on through governance. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { Spend { recipient: String, amount: Uint128, } } { \"spend\": { \"recipient\": \"terra1...\", \"amount\": \"100000000\" } } Name Type Description recipient String Recipient of community grant amount Uint128 Community grant amount","title":"Spend"},{"location":"Smart-Contracts/Community-Fund/#burn","text":"Burns a specified amount of WHALE tokens. Can only be issued by the the registered admin which is intended to be the Governance contract. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { Burn { amount: Uint128, } } { \"burn\": { \"amount\": \"100000000\" } } Name Type Description amount Uint128 Amount of WHALE to burn","title":"Burn"},{"location":"Smart-Contracts/Community-Fund/#querymsg","text":"","title":"QueryMsg"},{"location":"Smart-Contracts/Community-Fund/#config_1","text":"Gets the Community Fund contract configuration. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { Config {} } { \"config\": {} } Name Type Description","title":"Config"},{"location":"Smart-Contracts/Community-Fund/#configresponse","text":"#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] pub struct ConfigResponse { pub token_addr: Addr, } { \"token_addr\": \"terra1...\", } Name Type Description token_addr CanonicalAddr Contract address of Whale Token","title":"ConfigResponse"},{"location":"Smart-Contracts/Community-Fund/#admin","text":"Gets the Community Fund contract registered Admin. On launch and thereafter this should be the Governance contract. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { Admin {} } { \"admin\": {} } Name Type Description","title":"Admin"},{"location":"Smart-Contracts/Community-Fund/#adminresponse","text":"Note: The AdminResponse object is imported from the cw_controllers package. This definition may change as that package is updated #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema, Debug)] pub struct AdminResponse { pub admin: Option<String>, } { \"admin\": \"terra1...\", } Name Type Description admin CanonicalAddr Contract address of registered Admin of the contract","title":"AdminResponse"},{"location":"Smart-Contracts/Governance/","text":"Gov The Gov Contract contains logic for holding governance polls and handling Whale Token (WHALE) staking, and allows White Whale Protocol to be governed by its users in a decentralized manner. After the initial bootstrapping of White Whale Protocol's contracts, the Gov Contract is assigned to be the owner of all contracts in White Whale Protocol. New proposals for change are submitted as polls, and are voted on by WHALE stakers through the voting procedure . Polls can contain messages that can be executed directly without changing the White Whale Protocol code. References The Governance contract is based both on the examples set out by the Mirror Protocol , Anchor Protocol and their respective community contracts. Config Key Type Description owner CanonicalAddr Address of contract owner whale_token CanonicalAddr Contract address of Whale Token (WHALE) quorum Decimal Minimum percentage of participation required for a poll to pass threshold Decimal Minimum percentage of yes votes required for a poll to pass voting_period u64 Number of blocks during which votes can be cast [blocks] timelock_period u64 Number of blocks required after a poll pass before executing changes [blocks] expiration_period u64 Number of blocks after a poll's voting period during which the poll can be executed [blocks] proposal_deposit Uint128 Minimum WHALE deposit required for submitting a new poll snapshot_period u64 Window of time (number of blocks) allowed for poll snapshot before a poll's end [blocks] InstantiateMsg #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] pub struct InstantiateMsg { pub quorum: Decimal, pub threshold: Decimal, pub voting_period: u64, pub timelock_period: u64, pub expiration_period: u64, pub proposal_deposit: Uint128, pub snapshot_period: u64, } { \"quorum\": \"0.1\", \"threshold\": \"0.5\", \"voting_period\": 123456, \"timelock_period\": 123456, \"expiration_period\": 123456, \"proposal_deposit\": \"100000000\", \"snapshot_period\": 123456 } Key Type Description quorum Decimal Minimum percentage of participation required for a poll to pass threshold Decimal Minimum percentage of yes votes required for a poll to pass voting_period u64 Number of blocks during which votes can be cast [blocks] timelock_period u64 Number of blocks required after a poll pass before executing changes [blocks] expiration_period u64 Number of blocks after a poll's voting period during which the poll can be executed [blocks] proposal_deposit Uint128 Minimum WHALE deposit required for submitting a new poll snapshot_period u64 Window of time (number of blocks) allowed for poll snapshot before a poll's end [blocks] ExecuteMsg Receive Can be called during a CW20 token transfer when the Gov contract is the recipient. Allows the token transfer to execute a Receive Hook as a subsequent action within the same transaction. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { Receive { amount: Uint128, sender: HumanAddr, msg: Option<Binary>, } } { \"receive\": { \"amount\": \"10000000\", \"sender\": \"terra1...\", \"msg\": \"eyAiZXhlY3V0ZV9tc2ciOiAiYmluYXJ5IiB9\" } } Key Type Description amount Uint128 Amount of tokens received sender HumanAddr Sender of token transfer msg * Binary Base64-encoded JSON of Receive Hook * = optional RegisterContracts Registers the contract addresses (i.e. Whale Token, WHALE) to Gov. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { RegisterContracts { whale_token: HumanAddr, } } { \"register_contracts\": { \"whale_token\": \"terra1...\", } } Key Type Description whale_token HumanAddr Contract address of Whale Token (WHALE) UpdateConfig Updates the configuration of the Gov contract. {% tabs %} {% tab title=\"Rust\" %} #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { UpdateConfig { owner: Option<HumanAddr>, quorum: Option<Decimal>, threshold: Option<Decimal>, voting_period: Option<u64>, timelock_period: Option<u64>, expiration_period: Option<u64>, proposal_deposit: Option<Uint128>, snapshot_period: Option<u64>, } } { \"update_config\": { \"owner\": \"terra1...\", \"quorum\": \"0.1\", \"threshold\": \"0.1\", \"voting_period\": 123456, \"timelock_period\": 123456, \"expiration_period\": 123456, \"proposal_deposit\": \"100000000\", \"snapshot_period\": 123456 } } Key Type Description owner * HumanAddr New address of contract owner quorum * Decimal New percentage of participation (of total staked WHALE) required for a poll to pass threshold * Decimal New percentage of yes votes required for a poll to pass voting_period * u64 New number of blocks during which votes for a poll can be cast after it has finished its deposit [blocks] timelock_period * u64 New number of blocks required after a poll pass before executing changes [blocks] expiration_period * u64 New number of blocks after a poll's voting period during which the poll can be executed [blocks] proposal_deposit * Uint128 New minimum WHALE deposit required for a poll to enter voting snapshot_period * u64 New window of time (number of blocks) allowed for poll snapshot before a poll's end [blocks] * = optional CastVote Submits a user's vote for an active poll. Once a user has voted, they cannot change their vote with subsequent messages (increasing voting power, changing vote option, cancelling vote, etc.) #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { CastVote { poll_id: u64, vote: VoteOption, amount: Uint128, } } #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum VoteOption { Yes, No, } { \"cast_vote\": { \"poll_id\": 8, \"vote\": \"yes\", \"amount\": \"10000000\" } } Key Type Description poll_id u64 Poll ID vote VoteOption Can be yes or no amount Uint128 Amount of voting power (staked WHALE) to allocate WithdrawVotingTokens Removes specified amount of staked WHALE tokens from a staking position and returns them to a user's balance. Withdraws all staked WHALE tokens if amount is not specified. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { WithdrawVotingTokens { amount: Option<Uint128>, } } { \"withdraw_voting_tokens\": { \"amount\": \"100000000\" } } Key Type Description amount * Uint128 Amount of WHALE tokens to withdraw * = optional EndPoll Can be issued by anyone to end the voting for an active poll. Triggers tally the results to determine whether the poll has passed. The current block height must exceed the end height of voting phase. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { EndPoll { poll_id: u64, } } { \"end_poll\": { \"poll_id\": 8 } } Key Type Description poll_id u64 Poll ID ExecutePoll Can be issued by anyone to implement into action the contents of a passed poll. The current block height must exceed the end height of the poll's effective delay. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { ExecutePoll { poll_id: u64, } } { \"execute_poll\": { \"poll_id\": 8 } } Key Type Description poll_id u64 Poll ID ExpirePoll Can be issued by anyone to expire a poll. Requires the poll to be neither be a text proposal nor passed. The current block height must be more than the expiration period from the poll's end height. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { ExpirePoll { poll_id: u64, } } { \"expire_poll\": { \"poll_id\": 8 } } Key Type Description poll_id u64 Poll ID SnapshotPoll Snapshots the total amount of staked WHALE and stores the number to the specified poll. This staked WHALE amount is used to determine the degree of participation for this poll, calculated by dividing the total amount of WHALE voted to the poll with the total staked WHALE supply at the time of EndPoll . Can only be issued within a window of snapshot_period blocks before the poll's end_height . #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { SnapshotPoll { poll_id: u64, } } { \"snapshot_poll\": { \"poll_id\": 8 } } Key Type Description poll_id u64 Poll ID Receive Hooks StakeVotingTokens {% hint style=\"danger\" %} WARNING Sending WHALE tokens to the Gov contract without issuing this hook will lead to PERMANENT LOSS OF FUNDS and will be irrevocably donated to the reward pool for stakers. {% endhint %} Issued when sending WHALE tokens to the Gov contract to add them to their WHALE staking position. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum Cw20HookMsg { StakeVotingTokens {} } { \"stake_voting_tokens\": {} } Key Type Description CreatePoll Issued when sending WHALE tokens to the Gov contract to create a new poll. Will only succeed if the amount of tokens sent meets the configured proposal_deposit amount. Can contain a list of generic messages to be issued by the Gov contract if it passes (can invoke messages in other contracts it owns). #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum Cw20HookMsg { CreatePoll { title: String, description: String, link: Option<String>, execute_msgs: Option<Vec<ExecuteMsg>>, } } #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub struct ExecuteMsg { pub order: u64, pub contract: HumanAddr, pub msg: Binary, } { \"create_poll\": { \"title\": \"...\", \"description\": \"...\", \"link\": \"https://...\", \"execute_msgs\": [ { \"order\": 1, \"contract\": \"terra1...\", \"msg\": \"eyAiZXhlY3V0ZV9tc2ciOiAiYmluYXJ5IiB9\" }, { \"order\": 2, \"contract\": \"terra1...\", \"msg\": \"eyAiZXhlY3V0ZV9tc2ciOiAiYmluYXJ5IiB9\" } ] } } Key Type Description title String Poll title description String Poll description link * String URL to external post about poll (forum, PDF, etc.) execute_msgs * Vec<ExecuteMsg> List of governance messages to be issued by Gov contract upon poll execution Key Type Description order u64 Order sequence of message contract HumanAddr Contract address of governance message recipient msg Binary Base64-encoded JSON of governance message * = optional QueryMsg Config Gets the configuration for the Gov contract. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { Config {} } { \"config\": {} } Key Type Description ConfigResponse #[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema)] pub struct ConfigResponse { pub owner: HumanAddr, pub whale_token: HumanAddr, pub quorum: Decimal, pub threshold: Decimal, pub voting_period: u64, pub timelock_period: u64, pub expiration_period: u64, pub proposal_deposit: Uint128, pub snapshot_period: u64, } { \"owner\": \"terra1...\", \"whale_token\": \"terra1...\", \"quorum\": \"0.1\", \"threshold\": \"0.5\", \"voting_period\": 123456, \"timelock_period\": 123456, \"expiration_period\": 123456, \"proposal_deposit\": \"100000000\", \"snapshot_period\": 123456 } Key Type Description owner CanonicalAddr Address of contract owner whale_token CanonicalAddr Contract address of Whale Token (WHALE) quorum Decimal Minimum percentage of participation required for a poll to pass threshold Decimal Minimum percentage of yes votes required for a poll to pass voting_period u64 Number of blocks during which votes can be cast [blocks] timelock_period u64 Number of blocks required after a poll pass before executing changes [blocks] expiration_period u64 Number of blocks after a poll's voting period during which the poll can be executed [blocks] proposal_deposit Uint128 Minimum WHALE deposit required for submitting a new poll snapshot_period u64 Window of time (number of blocks) allowed for poll snapshot before a poll's end [blocks] State Gets state information for the Gov contract. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { State {} } { \"state\": {} } Key Type Description StateResponse #[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema)] pub struct StateResponse { pub poll_count: u64, pub total_share: Uint128, pub total_deposit: Uint128, } { \"poll_count\": 8, \"total_share\": \"100000000\", \"total_deposit\": \"100000000\" } Key Type Description poll_count u64 Total number of created polls total_share Uint128 Current total number of voting shares total_deposit Uint128 Total amount of WHALE currently deposited for poll creation Staker Gets information for the specified WHALE staker. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { Staker { address: HumanAddr, } } { \"staker\": { \"address\": \"terra1...\" } } Key Type Description address HumanAddr Address of staker StakerResponse #[derive(Serialize, Deserialize, Debug, Clone, PartialEq, JsonSchema)] pub struct StakerResponse { pub balance: Uint128, pub share: Uint128, pub locked_balance: Vec<(u64, VoterInfo)>, // (Voted Poll's ID, VoterInfo) } #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] pub struct VoterInfo { pub vote: VoteOption, pub balance: Uint128, } #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum VoteOption { Yes, No, } { \"balance\": \"100000000\", \"share\": \"100000000\", \"locked_balance\": [ [ 7, { \"vote\": \"yes\", \"balance\": \"100000000\" } ], [ 8, { \"vote\": \"no\", \"balance\": \"100000000\" } ] ] } Key Type Description balance Uint128 Amount of WHALE staked by staker share Uint128 Total voting shares owned by staker locked_balance Vec<(u64, VoterInfo)> List of (voted poll's ID, voter's vote information) Name Type Description vote VoteOption Vote type made by staker balance Uint128 Amount of staked WHALE locked to vote this poll Name Description yes Staker has voted for the proposal no Staker has voted against the proposal Poll Gets information for the specified poll. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { Poll { poll_id: u64, } } { \"poll\": { \"poll_id\": 8 } } Key Type Description poll_id u64 Poll ID PollResponse #[derive(Serialize, Deserialize, Debug, Clone, PartialEq, JsonSchema)] pub struct PollResponse { pub id: u64, pub creator: HumanAddr, pub status: PollStatus, pub end_height: u64, pub title: String, pub description: String, pub link: Option<String>, pub deposit_amount: Uint128, pub execute_data: Option<ExecuteMsg>, pub yes_votes: Uint128, // balance pub no_votes: Uint128, // balance pub staked_amount: Option<Uint128>, pub total_balance_at_end_poll: Option<Uint128>, } #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum PollStatus { InProgress, Passed, Rejected, Executed, Expired, } #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub struct ExecuteMsg { pub order: u64, pub contract: HumanAddr, pub msg: Binary, } { \"id\": 8, \"creator\": \"terra1...\", \"status\": \"executed\", \"end_height\": 123456, \"title\": \"...\", \"description\": \"...\", \"link\": \"https://...\", \"deposit_amount\": \"100000000\", \"execute_data\": [ { \"order\": 1, \"contract\": \"terra1...\", \"msg\": \"eyAiZXhlY3V0ZV9tc2ciOiAiYmluYXJ5IiB9\" }, { \"order\": 2, \"contract\": \"terra1...\", \"msg\": \"eyAiZXhlY3V0ZV9tc2ciOiAiYmluYXJ5IiB9\" } ], \"yes_votes\": \"100000000\", \"no_votes\": \"100000000\", \"staked_amount\": \"100000000\", \"total_balance_at_end_poll\": \"100000000\" } Key Type Description id u64 Poll ID creator HumanAddr Poll creator status PollStatus Current poll status end_height u64 Block number when voting for this poll closes [block] title String Poll title description String Poll description link * String URL to external post about poll (forum, PDF, etc.) deposit_amount Uint128 WHALE deposit used to submit poll execute_data * Vec<ExecuteMsg> List of governance messages to be issued upon poll execution yes_votes Uint128 Total yes votes (staked WHALE amount) for this poll no_votes Uint128 Total no votes (staked WHALE amount) for this poll staked_amount * Uint128 Total staked WHALE amount at time of poll snapshot total_balance_at_end_poll * Uint128 Total staked WHALE amount at the end of this poll Key Description InProgress Voting for this poll is currently in progress Passed This poll has been passed by governance Rejected This poll has been rejected by governance Executed This poll has been passed by governance and executed Expired This poll has been expired after rejection / execution Key Type Description order u64 Order sequence of message contract HumanAddr Contract address of governance message recipient msg Binary Base64-encoded JSON governance message * = optional Polls Gets information for all polls. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { Polls { filter: Option<PollStatus>, start_after: Option<u64>, limit: Option<u32>, order_by: Option<OrderBy>, } } #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum PollStatus { InProgress, Passed, Rejected, Executed, Expired, } #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum OrderBy { Asc, Desc, } { \"polls\": { \"filter\": \"passed\", \"start_after\": 8, \"limit\": 8, \"order_by\": \"asc\" } } Key Type Description filter * PollStatus Poll statuses to search for start_after * u64 Poll ID to start query at limit * u32 Maximum number of query entries order_by * OrderBy Order to make query Key Description InProgress Poll is currently in voting period Passed Poll has been passed by governance Rejected Poll has been rejected by governance Executed Poll has been passed and executed by governance Expired Poll has expired Key Description Asc Make query in ascending order Desc Make query in descending order * = optional PollsResponse #[derive(Serialize, Deserialize, Debug, Clone, PartialEq, JsonSchema)] pub struct PollsResponse { pub polls: Vec<PollResponse>, } #[derive(Serialize, Deserialize, Debug, Clone, PartialEq, JsonSchema)] pub struct PollResponse { pub id: u64, pub creator: HumanAddr, pub status: PollStatus, pub end_height: u64, pub title: String, pub description: String, pub link: Option<String>, pub deposit_amount: Uint128, pub execute_data: Option<ExecuteMsg>, pub yes_votes: Uint128, // balance pub no_votes: Uint128, // balance pub staked_amount: Option<Uint128>, pub total_balance_at_end_poll: Option<Uint128>, } #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum PollStatus { InProgress, Passed, Rejected, Executed, Expired, } #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub struct ExecuteMsg { pub order: u32, pub contract: HumanAddr, pub msg: Binary, } { \"polls\": [ { \"id\": 7, \"creator\": \"terra1...\", \"status\": \"passed\", \"end_height\": 123456, \"title\": \"...\", \"description\": \"...\", \"link\": \"https://...\", \"deposit_amount\": \"100000000\", \"execute_data\": [ { \"contract\": \"terra1...\", \"msg\": \"eyAiZXhlY3V0ZV9tc2ciOiAiYmluYXJ5IiB9\" }, { \"contract\": \"terra1...\", \"msg\": \"eyAiZXhlY3V0ZV9tc2ciOiAiYmluYXJ5IiB9\" } ], \"yes_votes\": \"100000000\", \"no_votes\": \"100000000\", \"staked_amount\": \"100000000\", \"total_balance_at_end_poll\": \"100000000\" }, { \"id\": 8, \"creator\": \"terra1...\", \"status\": \"executed\", \"end_height\": 123456, \"title\": \"...\", \"description\": \"...\", \"link\": \"https://...\", \"deposit_amount\": \"100000000\", \"execute_data\": [ { \"order\": 1, \"contract\": \"terra1...\", \"msg\": \"eyAiZXhlY3V0ZV9tc2ciOiAiYmluYXJ5IiB9\" }, { \"order\": 2, \"contract\": \"terra1...\", \"msg\": \"eyAiZXhlY3V0ZV9tc2ciOiAiYmluYXJ5IiB9\" } ], \"yes_votes\": \"100000000\", \"no_votes\": \"100000000\", \"staked_amount\": \"100000000\", \"total_balance_at_end_poll\": \"100000000\" } ] } Key Type Description polls Vec<PollResponse> List of poll information Key Type Description id u64 Poll ID creator HumanAddr Poll creator status PollStatus Current poll status end_height u64 Block number when voting for this poll closes [block] title String Poll title description String Poll description link * String URL to external post about poll (forum, PDF, etc.) deposit_amount Uint128 WHALE deposit used to submit poll execute_data * Vec<ExecuteMsg> List of governance messages to be issued upon poll execution yes_votes Uint128 Total yes votes (staked WHALE amount) for this poll no_votes Uint128 Total no votes (staked WHALE amount) for this poll staked_amount * Uint128 Total staked WHALE amount at time of poll snapshot total_balance_at_end_poll * Uint128 Total staked WHALE amount at the end of this poll Key Description InProgress Voting for this poll is currently in progress Passed This poll has been passed by governance Rejected This poll has been rejected by governance Executed This poll has been passed by governance and executed Expired This poll has been expired after rejection / execution Key Type Description order u64 Order sequence of message contract HumanAddr Contract address of governance message recipient msg Binary Base64-encoded JSON governance message * = optional Voters Gets voter information of the poll with the specified ID. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { Voters { poll_id: u64, start_after: Option<HumanAddr>, limit: Option<u32>, order_by: Option<OrderBy>, } } { \"voters\": { \"poll_id\": 8, \"start_after\": \"terra1..\", \"limit\": 8, \"order_by\": \"asc\" } } Key Type Description poll_id u64 ID of poll to query voters start_after * HumanAddr Address of voter to start query limit * u32 Maximum number of query entries order_by * OrderBy Order to make query Key Description Asc Make query in ascending order Desc Make query in descending order * = optional VotersResponse #[derive(Serialize, Deserialize, Debug, Clone, PartialEq, JsonSchema)] pub struct VotersResponse { pub voters: Vec<VotersResponseItem>, } #[derive(Serialize, Deserialize, Debug, Clone, PartialEq, JsonSchema)] pub struct VotersResponseItem { pub voter: HumanAddr, pub vote: VoteOption, pub balance: Uint128, } #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum VoteOption { Yes, No, } { \"voters\": [ { \"voter\": \"terra1...\", \"vote\": \"yes\", \"balance\": \"100000000\" }, { \"voter\": \"terra1...\", \"vote\": \"no\", \"balance\": \"100000000\" } ] } Key Type Description voters Vec<VotersResponseItem> List of voter information Key Type Description voter HumanAddr Address of voter vote VoteOption Vote type made by voter balance Uint128 Amount of staked WHALE locked to vote this poll Key Description yes Voter has voted for the proposal no Voter has voted against the proposal","title":"Gov"},{"location":"Smart-Contracts/Governance/#gov","text":"The Gov Contract contains logic for holding governance polls and handling Whale Token (WHALE) staking, and allows White Whale Protocol to be governed by its users in a decentralized manner. After the initial bootstrapping of White Whale Protocol's contracts, the Gov Contract is assigned to be the owner of all contracts in White Whale Protocol. New proposals for change are submitted as polls, and are voted on by WHALE stakers through the voting procedure . Polls can contain messages that can be executed directly without changing the White Whale Protocol code.","title":"Gov"},{"location":"Smart-Contracts/Governance/#references","text":"The Governance contract is based both on the examples set out by the Mirror Protocol , Anchor Protocol and their respective community contracts.","title":"References"},{"location":"Smart-Contracts/Governance/#config","text":"Key Type Description owner CanonicalAddr Address of contract owner whale_token CanonicalAddr Contract address of Whale Token (WHALE) quorum Decimal Minimum percentage of participation required for a poll to pass threshold Decimal Minimum percentage of yes votes required for a poll to pass voting_period u64 Number of blocks during which votes can be cast [blocks] timelock_period u64 Number of blocks required after a poll pass before executing changes [blocks] expiration_period u64 Number of blocks after a poll's voting period during which the poll can be executed [blocks] proposal_deposit Uint128 Minimum WHALE deposit required for submitting a new poll snapshot_period u64 Window of time (number of blocks) allowed for poll snapshot before a poll's end [blocks]","title":"Config"},{"location":"Smart-Contracts/Governance/#instantiatemsg","text":"#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] pub struct InstantiateMsg { pub quorum: Decimal, pub threshold: Decimal, pub voting_period: u64, pub timelock_period: u64, pub expiration_period: u64, pub proposal_deposit: Uint128, pub snapshot_period: u64, } { \"quorum\": \"0.1\", \"threshold\": \"0.5\", \"voting_period\": 123456, \"timelock_period\": 123456, \"expiration_period\": 123456, \"proposal_deposit\": \"100000000\", \"snapshot_period\": 123456 } Key Type Description quorum Decimal Minimum percentage of participation required for a poll to pass threshold Decimal Minimum percentage of yes votes required for a poll to pass voting_period u64 Number of blocks during which votes can be cast [blocks] timelock_period u64 Number of blocks required after a poll pass before executing changes [blocks] expiration_period u64 Number of blocks after a poll's voting period during which the poll can be executed [blocks] proposal_deposit Uint128 Minimum WHALE deposit required for submitting a new poll snapshot_period u64 Window of time (number of blocks) allowed for poll snapshot before a poll's end [blocks]","title":"InstantiateMsg"},{"location":"Smart-Contracts/Governance/#executemsg","text":"","title":"ExecuteMsg"},{"location":"Smart-Contracts/Governance/#receive","text":"Can be called during a CW20 token transfer when the Gov contract is the recipient. Allows the token transfer to execute a Receive Hook as a subsequent action within the same transaction. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { Receive { amount: Uint128, sender: HumanAddr, msg: Option<Binary>, } } { \"receive\": { \"amount\": \"10000000\", \"sender\": \"terra1...\", \"msg\": \"eyAiZXhlY3V0ZV9tc2ciOiAiYmluYXJ5IiB9\" } } Key Type Description amount Uint128 Amount of tokens received sender HumanAddr Sender of token transfer msg * Binary Base64-encoded JSON of Receive Hook * = optional","title":"Receive"},{"location":"Smart-Contracts/Governance/#registercontracts","text":"Registers the contract addresses (i.e. Whale Token, WHALE) to Gov. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { RegisterContracts { whale_token: HumanAddr, } } { \"register_contracts\": { \"whale_token\": \"terra1...\", } } Key Type Description whale_token HumanAddr Contract address of Whale Token (WHALE)","title":"RegisterContracts"},{"location":"Smart-Contracts/Governance/#updateconfig","text":"Updates the configuration of the Gov contract. {% tabs %} {% tab title=\"Rust\" %} #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { UpdateConfig { owner: Option<HumanAddr>, quorum: Option<Decimal>, threshold: Option<Decimal>, voting_period: Option<u64>, timelock_period: Option<u64>, expiration_period: Option<u64>, proposal_deposit: Option<Uint128>, snapshot_period: Option<u64>, } } { \"update_config\": { \"owner\": \"terra1...\", \"quorum\": \"0.1\", \"threshold\": \"0.1\", \"voting_period\": 123456, \"timelock_period\": 123456, \"expiration_period\": 123456, \"proposal_deposit\": \"100000000\", \"snapshot_period\": 123456 } } Key Type Description owner * HumanAddr New address of contract owner quorum * Decimal New percentage of participation (of total staked WHALE) required for a poll to pass threshold * Decimal New percentage of yes votes required for a poll to pass voting_period * u64 New number of blocks during which votes for a poll can be cast after it has finished its deposit [blocks] timelock_period * u64 New number of blocks required after a poll pass before executing changes [blocks] expiration_period * u64 New number of blocks after a poll's voting period during which the poll can be executed [blocks] proposal_deposit * Uint128 New minimum WHALE deposit required for a poll to enter voting snapshot_period * u64 New window of time (number of blocks) allowed for poll snapshot before a poll's end [blocks] * = optional","title":"UpdateConfig"},{"location":"Smart-Contracts/Governance/#castvote","text":"Submits a user's vote for an active poll. Once a user has voted, they cannot change their vote with subsequent messages (increasing voting power, changing vote option, cancelling vote, etc.) #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { CastVote { poll_id: u64, vote: VoteOption, amount: Uint128, } } #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum VoteOption { Yes, No, } { \"cast_vote\": { \"poll_id\": 8, \"vote\": \"yes\", \"amount\": \"10000000\" } } Key Type Description poll_id u64 Poll ID vote VoteOption Can be yes or no amount Uint128 Amount of voting power (staked WHALE) to allocate","title":"CastVote"},{"location":"Smart-Contracts/Governance/#withdrawvotingtokens","text":"Removes specified amount of staked WHALE tokens from a staking position and returns them to a user's balance. Withdraws all staked WHALE tokens if amount is not specified. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { WithdrawVotingTokens { amount: Option<Uint128>, } } { \"withdraw_voting_tokens\": { \"amount\": \"100000000\" } } Key Type Description amount * Uint128 Amount of WHALE tokens to withdraw * = optional","title":"WithdrawVotingTokens"},{"location":"Smart-Contracts/Governance/#endpoll","text":"Can be issued by anyone to end the voting for an active poll. Triggers tally the results to determine whether the poll has passed. The current block height must exceed the end height of voting phase. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { EndPoll { poll_id: u64, } } { \"end_poll\": { \"poll_id\": 8 } } Key Type Description poll_id u64 Poll ID","title":"EndPoll"},{"location":"Smart-Contracts/Governance/#executepoll","text":"Can be issued by anyone to implement into action the contents of a passed poll. The current block height must exceed the end height of the poll's effective delay. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { ExecutePoll { poll_id: u64, } } { \"execute_poll\": { \"poll_id\": 8 } } Key Type Description poll_id u64 Poll ID","title":"ExecutePoll"},{"location":"Smart-Contracts/Governance/#expirepoll","text":"Can be issued by anyone to expire a poll. Requires the poll to be neither be a text proposal nor passed. The current block height must be more than the expiration period from the poll's end height. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { ExpirePoll { poll_id: u64, } } { \"expire_poll\": { \"poll_id\": 8 } } Key Type Description poll_id u64 Poll ID","title":"ExpirePoll"},{"location":"Smart-Contracts/Governance/#snapshotpoll","text":"Snapshots the total amount of staked WHALE and stores the number to the specified poll. This staked WHALE amount is used to determine the degree of participation for this poll, calculated by dividing the total amount of WHALE voted to the poll with the total staked WHALE supply at the time of EndPoll . Can only be issued within a window of snapshot_period blocks before the poll's end_height . #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { SnapshotPoll { poll_id: u64, } } { \"snapshot_poll\": { \"poll_id\": 8 } } Key Type Description poll_id u64 Poll ID","title":"SnapshotPoll"},{"location":"Smart-Contracts/Governance/#receive-hooks","text":"","title":"Receive Hooks"},{"location":"Smart-Contracts/Governance/#stakevotingtokens","text":"{% hint style=\"danger\" %} WARNING Sending WHALE tokens to the Gov contract without issuing this hook will lead to PERMANENT LOSS OF FUNDS and will be irrevocably donated to the reward pool for stakers. {% endhint %} Issued when sending WHALE tokens to the Gov contract to add them to their WHALE staking position. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum Cw20HookMsg { StakeVotingTokens {} } { \"stake_voting_tokens\": {} } Key Type Description","title":"StakeVotingTokens"},{"location":"Smart-Contracts/Governance/#createpoll","text":"Issued when sending WHALE tokens to the Gov contract to create a new poll. Will only succeed if the amount of tokens sent meets the configured proposal_deposit amount. Can contain a list of generic messages to be issued by the Gov contract if it passes (can invoke messages in other contracts it owns). #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum Cw20HookMsg { CreatePoll { title: String, description: String, link: Option<String>, execute_msgs: Option<Vec<ExecuteMsg>>, } } #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub struct ExecuteMsg { pub order: u64, pub contract: HumanAddr, pub msg: Binary, } { \"create_poll\": { \"title\": \"...\", \"description\": \"...\", \"link\": \"https://...\", \"execute_msgs\": [ { \"order\": 1, \"contract\": \"terra1...\", \"msg\": \"eyAiZXhlY3V0ZV9tc2ciOiAiYmluYXJ5IiB9\" }, { \"order\": 2, \"contract\": \"terra1...\", \"msg\": \"eyAiZXhlY3V0ZV9tc2ciOiAiYmluYXJ5IiB9\" } ] } } Key Type Description title String Poll title description String Poll description link * String URL to external post about poll (forum, PDF, etc.) execute_msgs * Vec<ExecuteMsg> List of governance messages to be issued by Gov contract upon poll execution Key Type Description order u64 Order sequence of message contract HumanAddr Contract address of governance message recipient msg Binary Base64-encoded JSON of governance message * = optional","title":"CreatePoll"},{"location":"Smart-Contracts/Governance/#querymsg","text":"","title":"QueryMsg"},{"location":"Smart-Contracts/Governance/#config_1","text":"Gets the configuration for the Gov contract. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { Config {} } { \"config\": {} } Key Type Description","title":"Config"},{"location":"Smart-Contracts/Governance/#configresponse","text":"#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema)] pub struct ConfigResponse { pub owner: HumanAddr, pub whale_token: HumanAddr, pub quorum: Decimal, pub threshold: Decimal, pub voting_period: u64, pub timelock_period: u64, pub expiration_period: u64, pub proposal_deposit: Uint128, pub snapshot_period: u64, } { \"owner\": \"terra1...\", \"whale_token\": \"terra1...\", \"quorum\": \"0.1\", \"threshold\": \"0.5\", \"voting_period\": 123456, \"timelock_period\": 123456, \"expiration_period\": 123456, \"proposal_deposit\": \"100000000\", \"snapshot_period\": 123456 } Key Type Description owner CanonicalAddr Address of contract owner whale_token CanonicalAddr Contract address of Whale Token (WHALE) quorum Decimal Minimum percentage of participation required for a poll to pass threshold Decimal Minimum percentage of yes votes required for a poll to pass voting_period u64 Number of blocks during which votes can be cast [blocks] timelock_period u64 Number of blocks required after a poll pass before executing changes [blocks] expiration_period u64 Number of blocks after a poll's voting period during which the poll can be executed [blocks] proposal_deposit Uint128 Minimum WHALE deposit required for submitting a new poll snapshot_period u64 Window of time (number of blocks) allowed for poll snapshot before a poll's end [blocks]","title":"ConfigResponse"},{"location":"Smart-Contracts/Governance/#state","text":"Gets state information for the Gov contract. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { State {} } { \"state\": {} } Key Type Description","title":"State"},{"location":"Smart-Contracts/Governance/#stateresponse","text":"#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema)] pub struct StateResponse { pub poll_count: u64, pub total_share: Uint128, pub total_deposit: Uint128, } { \"poll_count\": 8, \"total_share\": \"100000000\", \"total_deposit\": \"100000000\" } Key Type Description poll_count u64 Total number of created polls total_share Uint128 Current total number of voting shares total_deposit Uint128 Total amount of WHALE currently deposited for poll creation","title":"StateResponse"},{"location":"Smart-Contracts/Governance/#staker","text":"Gets information for the specified WHALE staker. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { Staker { address: HumanAddr, } } { \"staker\": { \"address\": \"terra1...\" } } Key Type Description address HumanAddr Address of staker","title":"Staker"},{"location":"Smart-Contracts/Governance/#stakerresponse","text":"#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, JsonSchema)] pub struct StakerResponse { pub balance: Uint128, pub share: Uint128, pub locked_balance: Vec<(u64, VoterInfo)>, // (Voted Poll's ID, VoterInfo) } #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] pub struct VoterInfo { pub vote: VoteOption, pub balance: Uint128, } #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum VoteOption { Yes, No, } { \"balance\": \"100000000\", \"share\": \"100000000\", \"locked_balance\": [ [ 7, { \"vote\": \"yes\", \"balance\": \"100000000\" } ], [ 8, { \"vote\": \"no\", \"balance\": \"100000000\" } ] ] } Key Type Description balance Uint128 Amount of WHALE staked by staker share Uint128 Total voting shares owned by staker locked_balance Vec<(u64, VoterInfo)> List of (voted poll's ID, voter's vote information) Name Type Description vote VoteOption Vote type made by staker balance Uint128 Amount of staked WHALE locked to vote this poll Name Description yes Staker has voted for the proposal no Staker has voted against the proposal","title":"StakerResponse"},{"location":"Smart-Contracts/Governance/#poll","text":"Gets information for the specified poll. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { Poll { poll_id: u64, } } { \"poll\": { \"poll_id\": 8 } } Key Type Description poll_id u64 Poll ID","title":"Poll"},{"location":"Smart-Contracts/Governance/#pollresponse","text":"#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, JsonSchema)] pub struct PollResponse { pub id: u64, pub creator: HumanAddr, pub status: PollStatus, pub end_height: u64, pub title: String, pub description: String, pub link: Option<String>, pub deposit_amount: Uint128, pub execute_data: Option<ExecuteMsg>, pub yes_votes: Uint128, // balance pub no_votes: Uint128, // balance pub staked_amount: Option<Uint128>, pub total_balance_at_end_poll: Option<Uint128>, } #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum PollStatus { InProgress, Passed, Rejected, Executed, Expired, } #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub struct ExecuteMsg { pub order: u64, pub contract: HumanAddr, pub msg: Binary, } { \"id\": 8, \"creator\": \"terra1...\", \"status\": \"executed\", \"end_height\": 123456, \"title\": \"...\", \"description\": \"...\", \"link\": \"https://...\", \"deposit_amount\": \"100000000\", \"execute_data\": [ { \"order\": 1, \"contract\": \"terra1...\", \"msg\": \"eyAiZXhlY3V0ZV9tc2ciOiAiYmluYXJ5IiB9\" }, { \"order\": 2, \"contract\": \"terra1...\", \"msg\": \"eyAiZXhlY3V0ZV9tc2ciOiAiYmluYXJ5IiB9\" } ], \"yes_votes\": \"100000000\", \"no_votes\": \"100000000\", \"staked_amount\": \"100000000\", \"total_balance_at_end_poll\": \"100000000\" } Key Type Description id u64 Poll ID creator HumanAddr Poll creator status PollStatus Current poll status end_height u64 Block number when voting for this poll closes [block] title String Poll title description String Poll description link * String URL to external post about poll (forum, PDF, etc.) deposit_amount Uint128 WHALE deposit used to submit poll execute_data * Vec<ExecuteMsg> List of governance messages to be issued upon poll execution yes_votes Uint128 Total yes votes (staked WHALE amount) for this poll no_votes Uint128 Total no votes (staked WHALE amount) for this poll staked_amount * Uint128 Total staked WHALE amount at time of poll snapshot total_balance_at_end_poll * Uint128 Total staked WHALE amount at the end of this poll Key Description InProgress Voting for this poll is currently in progress Passed This poll has been passed by governance Rejected This poll has been rejected by governance Executed This poll has been passed by governance and executed Expired This poll has been expired after rejection / execution Key Type Description order u64 Order sequence of message contract HumanAddr Contract address of governance message recipient msg Binary Base64-encoded JSON governance message * = optional","title":"PollResponse"},{"location":"Smart-Contracts/Governance/#polls","text":"Gets information for all polls. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { Polls { filter: Option<PollStatus>, start_after: Option<u64>, limit: Option<u32>, order_by: Option<OrderBy>, } } #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum PollStatus { InProgress, Passed, Rejected, Executed, Expired, } #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum OrderBy { Asc, Desc, } { \"polls\": { \"filter\": \"passed\", \"start_after\": 8, \"limit\": 8, \"order_by\": \"asc\" } } Key Type Description filter * PollStatus Poll statuses to search for start_after * u64 Poll ID to start query at limit * u32 Maximum number of query entries order_by * OrderBy Order to make query Key Description InProgress Poll is currently in voting period Passed Poll has been passed by governance Rejected Poll has been rejected by governance Executed Poll has been passed and executed by governance Expired Poll has expired Key Description Asc Make query in ascending order Desc Make query in descending order * = optional","title":"Polls"},{"location":"Smart-Contracts/Governance/#pollsresponse","text":"#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, JsonSchema)] pub struct PollsResponse { pub polls: Vec<PollResponse>, } #[derive(Serialize, Deserialize, Debug, Clone, PartialEq, JsonSchema)] pub struct PollResponse { pub id: u64, pub creator: HumanAddr, pub status: PollStatus, pub end_height: u64, pub title: String, pub description: String, pub link: Option<String>, pub deposit_amount: Uint128, pub execute_data: Option<ExecuteMsg>, pub yes_votes: Uint128, // balance pub no_votes: Uint128, // balance pub staked_amount: Option<Uint128>, pub total_balance_at_end_poll: Option<Uint128>, } #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum PollStatus { InProgress, Passed, Rejected, Executed, Expired, } #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub struct ExecuteMsg { pub order: u32, pub contract: HumanAddr, pub msg: Binary, } { \"polls\": [ { \"id\": 7, \"creator\": \"terra1...\", \"status\": \"passed\", \"end_height\": 123456, \"title\": \"...\", \"description\": \"...\", \"link\": \"https://...\", \"deposit_amount\": \"100000000\", \"execute_data\": [ { \"contract\": \"terra1...\", \"msg\": \"eyAiZXhlY3V0ZV9tc2ciOiAiYmluYXJ5IiB9\" }, { \"contract\": \"terra1...\", \"msg\": \"eyAiZXhlY3V0ZV9tc2ciOiAiYmluYXJ5IiB9\" } ], \"yes_votes\": \"100000000\", \"no_votes\": \"100000000\", \"staked_amount\": \"100000000\", \"total_balance_at_end_poll\": \"100000000\" }, { \"id\": 8, \"creator\": \"terra1...\", \"status\": \"executed\", \"end_height\": 123456, \"title\": \"...\", \"description\": \"...\", \"link\": \"https://...\", \"deposit_amount\": \"100000000\", \"execute_data\": [ { \"order\": 1, \"contract\": \"terra1...\", \"msg\": \"eyAiZXhlY3V0ZV9tc2ciOiAiYmluYXJ5IiB9\" }, { \"order\": 2, \"contract\": \"terra1...\", \"msg\": \"eyAiZXhlY3V0ZV9tc2ciOiAiYmluYXJ5IiB9\" } ], \"yes_votes\": \"100000000\", \"no_votes\": \"100000000\", \"staked_amount\": \"100000000\", \"total_balance_at_end_poll\": \"100000000\" } ] } Key Type Description polls Vec<PollResponse> List of poll information Key Type Description id u64 Poll ID creator HumanAddr Poll creator status PollStatus Current poll status end_height u64 Block number when voting for this poll closes [block] title String Poll title description String Poll description link * String URL to external post about poll (forum, PDF, etc.) deposit_amount Uint128 WHALE deposit used to submit poll execute_data * Vec<ExecuteMsg> List of governance messages to be issued upon poll execution yes_votes Uint128 Total yes votes (staked WHALE amount) for this poll no_votes Uint128 Total no votes (staked WHALE amount) for this poll staked_amount * Uint128 Total staked WHALE amount at time of poll snapshot total_balance_at_end_poll * Uint128 Total staked WHALE amount at the end of this poll Key Description InProgress Voting for this poll is currently in progress Passed This poll has been passed by governance Rejected This poll has been rejected by governance Executed This poll has been passed by governance and executed Expired This poll has been expired after rejection / execution Key Type Description order u64 Order sequence of message contract HumanAddr Contract address of governance message recipient msg Binary Base64-encoded JSON governance message * = optional","title":"PollsResponse"},{"location":"Smart-Contracts/Governance/#voters","text":"Gets voter information of the poll with the specified ID. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { Voters { poll_id: u64, start_after: Option<HumanAddr>, limit: Option<u32>, order_by: Option<OrderBy>, } } { \"voters\": { \"poll_id\": 8, \"start_after\": \"terra1..\", \"limit\": 8, \"order_by\": \"asc\" } } Key Type Description poll_id u64 ID of poll to query voters start_after * HumanAddr Address of voter to start query limit * u32 Maximum number of query entries order_by * OrderBy Order to make query Key Description Asc Make query in ascending order Desc Make query in descending order * = optional","title":"Voters"},{"location":"Smart-Contracts/Governance/#votersresponse","text":"#[derive(Serialize, Deserialize, Debug, Clone, PartialEq, JsonSchema)] pub struct VotersResponse { pub voters: Vec<VotersResponseItem>, } #[derive(Serialize, Deserialize, Debug, Clone, PartialEq, JsonSchema)] pub struct VotersResponseItem { pub voter: HumanAddr, pub vote: VoteOption, pub balance: Uint128, } #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum VoteOption { Yes, No, } { \"voters\": [ { \"voter\": \"terra1...\", \"vote\": \"yes\", \"balance\": \"100000000\" }, { \"voter\": \"terra1...\", \"vote\": \"no\", \"balance\": \"100000000\" } ] } Key Type Description voters Vec<VotersResponseItem> List of voter information Key Type Description voter HumanAddr Address of voter vote VoteOption Vote type made by voter balance Uint128 Amount of staked WHALE locked to vote this poll Key Description yes Voter has voted for the proposal no Voter has voted against the proposal","title":"VotersResponse"},{"location":"Smart-Contracts/Profit-Check/","text":"Profit Check Profit check is used by the ust vault to see if a proposed trade is indeed profitable. before_trade is called before the trade to set the account balance and after_trade is called after the trade and checks whether a profit was made If the balance of the contract is smaller after the trade, a CancelLosingTrade error gets thrown which resets the contract state to the state before the contract call. If a profit is indeed made, it calls the vault to send a portion of the profit to the treasury contract as commission. Config Key Type Description vault_address String Address of the arb vault which will be interfaced with denom String Denom of the token to be checked on profit check operations last_balance Uint128 State value used during profit checking operations last_profit Uint128 State value used during profit checking operations InstantiateMsg #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] pub struct InstantiateMsg { pub vault_address: String, pub denom: String, } Key Type Description vault_address String Address of the arb vault which will be interfaced with denom String Denom of the token to be checked on profit check operations ExecuteMsg AfterTrade Checks if the balance increased after the trade. When called, the current balance of the vault is queried and if the balance is less than the last balance value which is retrieved from stored state, then a CancelLosingTrade error is raised. AfterTrade can only be called by the registered vault contract stored in State as vault_address . #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { AfterTrade {}, } BeforeTrade Resets last trade and sets current UST balance of caller. Simply put, prepares the contracts state to record the next AfterTrade result. BeforeTrade can only be called by the registered vault contract stored in State as vault_address . #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { BeforeTrade {}, } SetVault Change the registered Vault contract address for the Profit Check contract. Can only be called by the Admin of the contract. The registered vault_address is the only address able to call the Profit Check contracts BeforeTrade and AfterTrade functions. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { SetVault { vault_address: Addr } } QueryMsg LastBalance Gets the last_balance state value. This value is updated every time BeforeTrade is called. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { LastBalance {} } Key Type Description LastBalanceResponse #[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema)] pub struct LastBalanceResponse { pub last_balance: Uint128, } Key Type Description last_balance Uint128 Last recorded balance of the registered vault address. LastProfit Gets the last_profit state value. This value is reset every time BeforeTrade is called. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { LastProfit {} } Key Type Description LastProfitResponse #[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema)] pub struct LastProfitResponse { pub last_profit: Uint128, } Key Type Description last_profit Uint128 Last recorded profit of the registered vault address. Vault Gets the vault_address state value which represents the currently registered Vault contract address. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { Vault {} } Key Type Description VaultResponse #[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema)] pub struct VaultResponse { pub vault_address: Uint128, } Key Type Description vault_address Addr Contract address of the Vault contract that is registered with this Profit Check contract.","title":"Profit Check"},{"location":"Smart-Contracts/Profit-Check/#profit-check","text":"Profit check is used by the ust vault to see if a proposed trade is indeed profitable. before_trade is called before the trade to set the account balance and after_trade is called after the trade and checks whether a profit was made If the balance of the contract is smaller after the trade, a CancelLosingTrade error gets thrown which resets the contract state to the state before the contract call. If a profit is indeed made, it calls the vault to send a portion of the profit to the treasury contract as commission.","title":"Profit Check"},{"location":"Smart-Contracts/Profit-Check/#config","text":"Key Type Description vault_address String Address of the arb vault which will be interfaced with denom String Denom of the token to be checked on profit check operations last_balance Uint128 State value used during profit checking operations last_profit Uint128 State value used during profit checking operations","title":"Config"},{"location":"Smart-Contracts/Profit-Check/#instantiatemsg","text":"#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] pub struct InstantiateMsg { pub vault_address: String, pub denom: String, } Key Type Description vault_address String Address of the arb vault which will be interfaced with denom String Denom of the token to be checked on profit check operations","title":"InstantiateMsg"},{"location":"Smart-Contracts/Profit-Check/#executemsg","text":"","title":"ExecuteMsg"},{"location":"Smart-Contracts/Profit-Check/#aftertrade","text":"Checks if the balance increased after the trade. When called, the current balance of the vault is queried and if the balance is less than the last balance value which is retrieved from stored state, then a CancelLosingTrade error is raised. AfterTrade can only be called by the registered vault contract stored in State as vault_address . #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { AfterTrade {}, }","title":"AfterTrade"},{"location":"Smart-Contracts/Profit-Check/#beforetrade","text":"Resets last trade and sets current UST balance of caller. Simply put, prepares the contracts state to record the next AfterTrade result. BeforeTrade can only be called by the registered vault contract stored in State as vault_address . #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { BeforeTrade {}, }","title":"BeforeTrade"},{"location":"Smart-Contracts/Profit-Check/#setvault","text":"Change the registered Vault contract address for the Profit Check contract. Can only be called by the Admin of the contract. The registered vault_address is the only address able to call the Profit Check contracts BeforeTrade and AfterTrade functions. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { SetVault { vault_address: Addr } }","title":"SetVault"},{"location":"Smart-Contracts/Profit-Check/#querymsg","text":"","title":"QueryMsg"},{"location":"Smart-Contracts/Profit-Check/#lastbalance","text":"Gets the last_balance state value. This value is updated every time BeforeTrade is called. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { LastBalance {} } Key Type Description","title":"LastBalance"},{"location":"Smart-Contracts/Profit-Check/#lastbalanceresponse","text":"#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema)] pub struct LastBalanceResponse { pub last_balance: Uint128, } Key Type Description last_balance Uint128 Last recorded balance of the registered vault address.","title":"LastBalanceResponse"},{"location":"Smart-Contracts/Profit-Check/#lastprofit","text":"Gets the last_profit state value. This value is reset every time BeforeTrade is called. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { LastProfit {} } Key Type Description","title":"LastProfit"},{"location":"Smart-Contracts/Profit-Check/#lastprofitresponse","text":"#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema)] pub struct LastProfitResponse { pub last_profit: Uint128, } Key Type Description last_profit Uint128 Last recorded profit of the registered vault address.","title":"LastProfitResponse"},{"location":"Smart-Contracts/Profit-Check/#vault","text":"Gets the vault_address state value which represents the currently registered Vault contract address. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { Vault {} } Key Type Description","title":"Vault"},{"location":"Smart-Contracts/Profit-Check/#vaultresponse","text":"#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema)] pub struct VaultResponse { pub vault_address: Uint128, } Key Type Description vault_address Addr Contract address of the Vault contract that is registered with this Profit Check contract.","title":"VaultResponse"},{"location":"Smart-Contracts/Stablecoin-Arb/","text":"Terra Stablecoin Arbitrage Contracts The UST Arbitrage Contracts are our first step toward providing Anchor+ yields to depositors. These contracts are the endpoint for our bots and perform the UST -> LUNA -> UST transactions that stabilize the peg through minting/burning of luna. This doc is valid for both the Terraswap and Astroport arbitrage contracts. State Key Type Description vault_address CanonicalAddr Addresses of the UST vault seignorage_address CanonicalAddr Address of the seignorage swaps that are native to the Terra infrastructure pool_address CanonicalAddr Address of either the terraswap or astroport LUNA/UST pair. InstantiateMsg #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] pub struct InstantiateMsg { pub vault_address: String, pub seignorage_address: String, pub pool_address: String, pub asset_info: AssetInfo, } Key Type Description vault_address String Contract address of Anchor Money Market system. This is used for depositing and withdrawing from Anchor seignorage_address String Contract address of aUST token pool_address String Contract address of LP Contract to be interacted with treasury_address String Contract address of Treasury Contract asset_info AssetInfo Struct detailing the token to be used for trading (the vault base token) ExecuteMsg ExecuteArb Endpoint for the arbitrage bot to call. The arb bot provides the arb details and direction to the contract. These details are determined by the arbitrage bots. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { ExecuteArb { details: ArbDetails, above_peg: bool, } } #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] pub struct ArbDetails { pub asset: Asset, pub slippage: Decimal, pub belief_price: Decimal, } Key Type Description details ArbDetails Conveys the amount, max allowed slippage and belief price above_peg bool Conveys if UST is below or above peg AbovePegCallback After the stablecoin vault transfered the requested funds to this contract it will call the provided callback message. The AbovePegCallback and BelowPegCallback messages are both callback endpoints for the stablecoin vault. This endpoint can only be call by the vault. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { AbovePegCallback { details: ArbDetails, }, } Key Type Description details ArbDetails Conveys the amount, max allowed slippage and belief price BelowPegCallback After the stablecoin vault transfered the requested funds to this contract it will call the provided callback message. The AbovePegCallback and BelowPegCallback messages are both callback endpoints for the stablecoin vault. This endpoint can only be call by the vault. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { AbovePegCallback { details: ArbDetails, }, } Key Type Description details ArbDetails Conveys the amount, max allowed slippage and belief price SendTreasuryCommission Call executed by the profit check contract after a profitable trade. It forwards a portion of the profit to the treasury contract (aka war chest). The % of the profit sent as commission is set by the commission_fee. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { SendTreasuryCommission { profit: Uint128 }, } SetAdmin Change the established Admin for the Stablecoin Vault. Can only be called by the currently established Admin of the contract. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { SetAdmin { admin: Addr } } Key Type Description admin Addr Address of the new Admin. Callbacks These callbacks can only be called by the contract itself. No external address is allowed to execute these endpoints. AfterSuccessfulTradeCallback After a successful trade, which means the trade was able to execute given the slippage constraints, it sends all the available UST back to the stablecoin vault contract. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum CallbackMsg { AfterSuccessfulTradeCallback {}, } QueryMsg Config Gets the configuration for the arbitrage contract. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { Config {} }","title":"Terra Stablecoin Arbitrage Contracts"},{"location":"Smart-Contracts/Stablecoin-Arb/#terra-stablecoin-arbitrage-contracts","text":"The UST Arbitrage Contracts are our first step toward providing Anchor+ yields to depositors. These contracts are the endpoint for our bots and perform the UST -> LUNA -> UST transactions that stabilize the peg through minting/burning of luna. This doc is valid for both the Terraswap and Astroport arbitrage contracts.","title":"Terra Stablecoin Arbitrage Contracts"},{"location":"Smart-Contracts/Stablecoin-Arb/#state","text":"Key Type Description vault_address CanonicalAddr Addresses of the UST vault seignorage_address CanonicalAddr Address of the seignorage swaps that are native to the Terra infrastructure pool_address CanonicalAddr Address of either the terraswap or astroport LUNA/UST pair.","title":"State"},{"location":"Smart-Contracts/Stablecoin-Arb/#instantiatemsg","text":"#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] pub struct InstantiateMsg { pub vault_address: String, pub seignorage_address: String, pub pool_address: String, pub asset_info: AssetInfo, } Key Type Description vault_address String Contract address of Anchor Money Market system. This is used for depositing and withdrawing from Anchor seignorage_address String Contract address of aUST token pool_address String Contract address of LP Contract to be interacted with treasury_address String Contract address of Treasury Contract asset_info AssetInfo Struct detailing the token to be used for trading (the vault base token)","title":"InstantiateMsg"},{"location":"Smart-Contracts/Stablecoin-Arb/#executemsg","text":"","title":"ExecuteMsg"},{"location":"Smart-Contracts/Stablecoin-Arb/#executearb","text":"Endpoint for the arbitrage bot to call. The arb bot provides the arb details and direction to the contract. These details are determined by the arbitrage bots. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { ExecuteArb { details: ArbDetails, above_peg: bool, } } #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] pub struct ArbDetails { pub asset: Asset, pub slippage: Decimal, pub belief_price: Decimal, } Key Type Description details ArbDetails Conveys the amount, max allowed slippage and belief price above_peg bool Conveys if UST is below or above peg","title":"ExecuteArb"},{"location":"Smart-Contracts/Stablecoin-Arb/#abovepegcallback","text":"After the stablecoin vault transfered the requested funds to this contract it will call the provided callback message. The AbovePegCallback and BelowPegCallback messages are both callback endpoints for the stablecoin vault. This endpoint can only be call by the vault. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { AbovePegCallback { details: ArbDetails, }, } Key Type Description details ArbDetails Conveys the amount, max allowed slippage and belief price","title":"AbovePegCallback"},{"location":"Smart-Contracts/Stablecoin-Arb/#belowpegcallback","text":"After the stablecoin vault transfered the requested funds to this contract it will call the provided callback message. The AbovePegCallback and BelowPegCallback messages are both callback endpoints for the stablecoin vault. This endpoint can only be call by the vault. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { AbovePegCallback { details: ArbDetails, }, } Key Type Description details ArbDetails Conveys the amount, max allowed slippage and belief price","title":"BelowPegCallback"},{"location":"Smart-Contracts/Stablecoin-Arb/#sendtreasurycommission","text":"Call executed by the profit check contract after a profitable trade. It forwards a portion of the profit to the treasury contract (aka war chest). The % of the profit sent as commission is set by the commission_fee. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { SendTreasuryCommission { profit: Uint128 }, }","title":"SendTreasuryCommission"},{"location":"Smart-Contracts/Stablecoin-Arb/#setadmin","text":"Change the established Admin for the Stablecoin Vault. Can only be called by the currently established Admin of the contract. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { SetAdmin { admin: Addr } } Key Type Description admin Addr Address of the new Admin.","title":"SetAdmin"},{"location":"Smart-Contracts/Stablecoin-Arb/#callbacks","text":"These callbacks can only be called by the contract itself. No external address is allowed to execute these endpoints.","title":"Callbacks"},{"location":"Smart-Contracts/Stablecoin-Arb/#aftersuccessfultradecallback","text":"After a successful trade, which means the trade was able to execute given the slippage constraints, it sends all the available UST back to the stablecoin vault contract. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum CallbackMsg { AfterSuccessfulTradeCallback {}, }","title":"AfterSuccessfulTradeCallback"},{"location":"Smart-Contracts/Stablecoin-Arb/#querymsg","text":"","title":"QueryMsg"},{"location":"Smart-Contracts/Stablecoin-Arb/#config","text":"Gets the configuration for the arbitrage contract. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { Config {} }","title":"Config"},{"location":"Smart-Contracts/Stablecoin-Vault/","text":"Stablecoin Vault The Stablecoin Vault Contract is one of the flagship contracts of the White Whale protocol. Combined with a bot system, the Vault contract allows for in-house automated trading of UST in response to a de-pegging event or to just perform a simple arbitrage operation. The Stablecoin Vault also allows arbitrary users to request flashloans in return for a small fee. State Key Type Description whitelisted_contracts Vec Addresses of whitelisted contracts allow_non_whitelisted bool Boolean that indicates if non-whitelisted addresses are allowed to get a flashloan anchor_money_market_address CanonicalAddr Contract address of Anchor Money Market system. This is used for depositing and withdrawing from Anchor aust_address CanonicalAddr Contract address of aUST token profit_check_address CanonicalAddr Contract address of Profit Check Contract. InstantiateMsg #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] pub struct InstantiateMsg { pub anchor_money_market_address: String, pub aust_address: String, pub profit_check_address: String, pub treasury_addr: String, pub asset_info: AssetInfo, pub token_code_id: u64, pub treasury_fee: Decimal, pub flash_loan_fee: Decimal, pub commission_fee: Decimal, pub stable_cap: Uint128, pub vault_lp_token_name: Option<String>, pub vault_lp_token_symbol: Option<String>, } Key Type Description anchor_money_market_address String Contract address of Anchor Money Market system. This is used for depositing and withdrawing from Anchor aust_address String Contract address of aUST token profit_check_address String Contract address of Profit Check Contract treasury_address String Contract address of Treasury Contract asset_info AssetInfo Struct detailing the token to be used for trading (the vault base token) token_code_id u64 The Stored Code Object ID for the LP token creator. This is used on instantiation to creation an LP token when the Vault is created treasury_fee Decimal Configurable fee rate for the treasury contract. commission_fee Decimal Fee on every profitable action on the vault, sent to the treasury. stable_cap Uint128 Initial UST_CAP value which represents the amount of liquid UST kept outside of Anchor vault_lp_token_name Uint128 Absolute max rate for community fund vault_lp_token_symbol Uint128 Absolute max rate for community fund ExecuteMsg #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { Receive(Cw20ReceiveMsg), ProvideLiquidity { asset: Asset, }, SetStableCap { stable_cap: Uint128, }, SetFee { flash_loan_fee: Option<Fee>, treasury_fee: Option<Fee>, commission_fee: Option<Fee> }, SetAdmin { admin: String, }, AddToWhitelist { contract_addr: String, }, RemoveFromWhitelist { contract_addr: String, }, UpdateState { anchor_money_market_address: Option<String>, aust_address: Option<String>, profit_check_address: Option<String>, allow_non_whitelisted: Option<bool>, }, FlashLoan { payload: FlashLoanPayload, }, Callback(CallbackMsg), } Receive Can be called during a CW20 token transfer when tokens are deposited into the Stablecoin Vault. Allows the token transfer to execute a Receive Hook as a subsequent action within the same transaction. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { Receive { amount: Uint128, sender: HumanAddr, msg: Option<Binary>, } } Key Type Description amount Uint128 Amount of tokens received sender HumanAddr Sender of token transfer msg * Binary Base64-encoded JSON of Receive Hook * = optional FlashLoan Attempt to get a flashloan from the vault. The requested funds and callback message are encapsuled in the FlashLoanPayload struct. The provided callback should be the series of messages the caller wants to perform with the requested amount of funds. If needed, funds are withdrawn from anchor. All incurred fees are paid by the borrower. Two calls to the profit_check logic surround the flashloan callback msg to ensure the trade only finalizes if the contract makes a profit. Key Type Description requested_asset Asset Requested asset, contains amount an assetinfo callback Binary The encoded callback msg provided by the calling contract { \"requested_asset\": { \"info\": { \"denom\": \"uusd\" } \"amount\": \"1000000\" }, \"callback\": \"<binary>\", } ProvideLiquidity Attempt to perform a deposit into the vault by providing UST. White Whale does not charge any additional fees on depositing. In the event of a successful deposit, the address will receive newly minted LP tokens representing their share of the Vault's liquidity. These LP tokens are then required when an account wishes to withdraw liquidity. This function should be called alongside a deposit of UST into the contract. Key Type Description asset Asset Asset to be provided as liquidity. Includes asset info and amount. { \"provide_liquidity\": { \"asset\": { \"info\": { \"native_token\": { \"denom\": \"uusd\" }, }, \"amount\": \"1000000\", } } SetStableCap Change the UST_CAP parameter for the Stablecoin Vault which represents the cap of liquid UST kept in the vault. Deposits in excess of the cap will be deposited into anchor. Can only be called by the established Admin of the contract. Key Type Description stable_cap Uint128 New UST_CAP value to be set SetAdmin Change the established Admin for the Stablecoin Vault. Can only be called by the currently established Admin of the contract. Key Type Description admin Addr Address of the new Admin. AddToWhitelist Adds the provided address to the whitelist. Can only be called by Admin. Key Type Description contract_addr Addr Address of the new whitelisted contract. RemoveFromWhitelist Removes the provided address from the whitelist. Can only be called by Admin. Key Type Description contract_addr Addr Address of the whitelisted contract. SetFee Update the fee information for 1 or more of the associated fee structures. Can only be called by Admin. Key Type Description flash_loan_fee * Fee New fee value for fees associated with non-whitelisted flashloans treasury_fee * Fee New fee values for fee allocation to the Treasury * = optional UpdateState Update the state of the contract with the provided arguments. Key Type Description anchor_money_market_address * String New address for the anchor money market aust_address * String New aUST address profit_check_address * String New profit check contract address allow_non_whitelisted * bool New boolean for allowing non-whitelisted contracts to take out flashloans * = optional Receive Hooks Payable functions when you send a payment to the contract with an appropriate message. WithdrawLiquidity Attempt to withdraw deposits. Fees are calculated and deducted. If the Vault has available funds in Anchor it will attempt to payout the withdrawal request by first withdrawing some funds from Anchor to fund the withdrawal request. Luna holdings are not eligible for withdrawal. LP tokens submitted with a withdrawal request will be burned. The Treasury withdraw fee is paid out by transfering ownership of a fraction of the LP tokens to the treasury contract. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum Cw20HookMsg { WithdrawLiquidity {}, } Callbacks Callback Functions are used in conjunction with other ExecuteMsg functions in the Stablecoin Vault. AfterSuccessfulLoanCallback After a successful loan happens, check if the contract currently holds more than the STABLE_CAP * 1.5. If it does, Leave STABLE_CAP in UST and deposit all other UST in Anchor. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum CallbackMsg { AfterSuccessfulLoanCallback {}, } QueryMsg #[cfg_attr(not(feature = \"library\"), entry_point)] pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -> StdResult<Binary> { match msg { QueryMsg::PoolConfig {} => to_binary(&try_query_config(deps)?), QueryMsg::PoolState {} => to_binary(&try_query_pool_state(deps)?), QueryMsg::State {} => to_binary(&try_query_state(deps)?), QueryMsg::Fees {} => to_binary(&query_fees(deps)?), QueryMsg::VaultValue {} => to_binary(&query_total_value(deps)?), QueryMsg::EstimateWithdrawFee { amount } => { to_binary(&estimate_withdraw_fee(deps, amount)?) } } } State Returns the contract state. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { State {} } VaultValue Returns the total value of UST and aUST held in the contract in UST. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { VaultValue {} } PoolConfig Gets the configuration for the Stablecoin Vault contract pool. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { PoolConfig {} } PoolInfo #[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema)] pub struct PoolInfo { pub asset_infos: [AssetInfo; 2], pub contract_addr: Addr, pub liquidity_token: Addr, pub stable_cap: Uint128 } Key Type Description asset_infos [AssetInfo; 2] Collection of Assets in the Pool and their information. In our case UST and aUST contract_addr Addr This contract's address liquidity_token Addr Address of the LP token stable_cap Uint128 Stablecoin reserve/cap amount PoolState Gets the pool state, including the balances of the holdings. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { PoolState {} } PoolResponse #[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema)] pub struct PoolResponse { pub asset_infos: [Asset; 2], pub contract_addr: Addr, pub liquidity_token: Addr, pub stable_cap: Uint128 } Key Type Description asset_infos [AssetInfo; 2] Collection of Assets in the Pool and their information. In our case UST and aUST contract_addr Addr This contract's address liquidity_token Addr Address of the LP token stable_cap Uint128 Stablecoin reserve/cap amount Fees Gets the fees structure set by the Stablecoin Vault contract. FeeResponse pub struct FeeResponse { pub fees: VaultFee, } VaultFee Key Type Description flash_loan_fee Fee Flashloan fee expected to be paid by non-whitelisted contracts treasury_fee Fee Fee information related to Treasury fee distribution. treasury_addr CanonicalAddr Address of the Community Fund Contract EstimateWithdrawFee Query to provide an estimate of the Stablecoin Vault withdrawal fee minus tax. Key Type Description amount Uint128 Deposit amount to calculate a deposit fee for EstimateWithdrawFeeResponse pub struct EstimateWithdrawFeeResponse { pub fee: Vec<Coin>, } Key Type Description fee Vec Vector containing fee info in the form of Coins","title":"Stablecoin Vault"},{"location":"Smart-Contracts/Stablecoin-Vault/#stablecoin-vault","text":"The Stablecoin Vault Contract is one of the flagship contracts of the White Whale protocol. Combined with a bot system, the Vault contract allows for in-house automated trading of UST in response to a de-pegging event or to just perform a simple arbitrage operation. The Stablecoin Vault also allows arbitrary users to request flashloans in return for a small fee.","title":"Stablecoin Vault"},{"location":"Smart-Contracts/Stablecoin-Vault/#state","text":"Key Type Description whitelisted_contracts Vec Addresses of whitelisted contracts allow_non_whitelisted bool Boolean that indicates if non-whitelisted addresses are allowed to get a flashloan anchor_money_market_address CanonicalAddr Contract address of Anchor Money Market system. This is used for depositing and withdrawing from Anchor aust_address CanonicalAddr Contract address of aUST token profit_check_address CanonicalAddr Contract address of Profit Check Contract.","title":"State"},{"location":"Smart-Contracts/Stablecoin-Vault/#instantiatemsg","text":"#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] pub struct InstantiateMsg { pub anchor_money_market_address: String, pub aust_address: String, pub profit_check_address: String, pub treasury_addr: String, pub asset_info: AssetInfo, pub token_code_id: u64, pub treasury_fee: Decimal, pub flash_loan_fee: Decimal, pub commission_fee: Decimal, pub stable_cap: Uint128, pub vault_lp_token_name: Option<String>, pub vault_lp_token_symbol: Option<String>, } Key Type Description anchor_money_market_address String Contract address of Anchor Money Market system. This is used for depositing and withdrawing from Anchor aust_address String Contract address of aUST token profit_check_address String Contract address of Profit Check Contract treasury_address String Contract address of Treasury Contract asset_info AssetInfo Struct detailing the token to be used for trading (the vault base token) token_code_id u64 The Stored Code Object ID for the LP token creator. This is used on instantiation to creation an LP token when the Vault is created treasury_fee Decimal Configurable fee rate for the treasury contract. commission_fee Decimal Fee on every profitable action on the vault, sent to the treasury. stable_cap Uint128 Initial UST_CAP value which represents the amount of liquid UST kept outside of Anchor vault_lp_token_name Uint128 Absolute max rate for community fund vault_lp_token_symbol Uint128 Absolute max rate for community fund","title":"InstantiateMsg"},{"location":"Smart-Contracts/Stablecoin-Vault/#executemsg","text":"#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { Receive(Cw20ReceiveMsg), ProvideLiquidity { asset: Asset, }, SetStableCap { stable_cap: Uint128, }, SetFee { flash_loan_fee: Option<Fee>, treasury_fee: Option<Fee>, commission_fee: Option<Fee> }, SetAdmin { admin: String, }, AddToWhitelist { contract_addr: String, }, RemoveFromWhitelist { contract_addr: String, }, UpdateState { anchor_money_market_address: Option<String>, aust_address: Option<String>, profit_check_address: Option<String>, allow_non_whitelisted: Option<bool>, }, FlashLoan { payload: FlashLoanPayload, }, Callback(CallbackMsg), }","title":"ExecuteMsg"},{"location":"Smart-Contracts/Stablecoin-Vault/#receive","text":"Can be called during a CW20 token transfer when tokens are deposited into the Stablecoin Vault. Allows the token transfer to execute a Receive Hook as a subsequent action within the same transaction. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { Receive { amount: Uint128, sender: HumanAddr, msg: Option<Binary>, } } Key Type Description amount Uint128 Amount of tokens received sender HumanAddr Sender of token transfer msg * Binary Base64-encoded JSON of Receive Hook * = optional","title":"Receive"},{"location":"Smart-Contracts/Stablecoin-Vault/#flashloan","text":"Attempt to get a flashloan from the vault. The requested funds and callback message are encapsuled in the FlashLoanPayload struct. The provided callback should be the series of messages the caller wants to perform with the requested amount of funds. If needed, funds are withdrawn from anchor. All incurred fees are paid by the borrower. Two calls to the profit_check logic surround the flashloan callback msg to ensure the trade only finalizes if the contract makes a profit. Key Type Description requested_asset Asset Requested asset, contains amount an assetinfo callback Binary The encoded callback msg provided by the calling contract { \"requested_asset\": { \"info\": { \"denom\": \"uusd\" } \"amount\": \"1000000\" }, \"callback\": \"<binary>\", }","title":"FlashLoan"},{"location":"Smart-Contracts/Stablecoin-Vault/#provideliquidity","text":"Attempt to perform a deposit into the vault by providing UST. White Whale does not charge any additional fees on depositing. In the event of a successful deposit, the address will receive newly minted LP tokens representing their share of the Vault's liquidity. These LP tokens are then required when an account wishes to withdraw liquidity. This function should be called alongside a deposit of UST into the contract. Key Type Description asset Asset Asset to be provided as liquidity. Includes asset info and amount. { \"provide_liquidity\": { \"asset\": { \"info\": { \"native_token\": { \"denom\": \"uusd\" }, }, \"amount\": \"1000000\", } }","title":"ProvideLiquidity"},{"location":"Smart-Contracts/Stablecoin-Vault/#setstablecap","text":"Change the UST_CAP parameter for the Stablecoin Vault which represents the cap of liquid UST kept in the vault. Deposits in excess of the cap will be deposited into anchor. Can only be called by the established Admin of the contract. Key Type Description stable_cap Uint128 New UST_CAP value to be set","title":"SetStableCap"},{"location":"Smart-Contracts/Stablecoin-Vault/#setadmin","text":"Change the established Admin for the Stablecoin Vault. Can only be called by the currently established Admin of the contract. Key Type Description admin Addr Address of the new Admin.","title":"SetAdmin"},{"location":"Smart-Contracts/Stablecoin-Vault/#addtowhitelist","text":"Adds the provided address to the whitelist. Can only be called by Admin. Key Type Description contract_addr Addr Address of the new whitelisted contract.","title":"AddToWhitelist"},{"location":"Smart-Contracts/Stablecoin-Vault/#removefromwhitelist","text":"Removes the provided address from the whitelist. Can only be called by Admin. Key Type Description contract_addr Addr Address of the whitelisted contract.","title":"RemoveFromWhitelist"},{"location":"Smart-Contracts/Stablecoin-Vault/#setfee","text":"Update the fee information for 1 or more of the associated fee structures. Can only be called by Admin. Key Type Description flash_loan_fee * Fee New fee value for fees associated with non-whitelisted flashloans treasury_fee * Fee New fee values for fee allocation to the Treasury * = optional","title":"SetFee"},{"location":"Smart-Contracts/Stablecoin-Vault/#updatestate","text":"Update the state of the contract with the provided arguments. Key Type Description anchor_money_market_address * String New address for the anchor money market aust_address * String New aUST address profit_check_address * String New profit check contract address allow_non_whitelisted * bool New boolean for allowing non-whitelisted contracts to take out flashloans * = optional","title":"UpdateState"},{"location":"Smart-Contracts/Stablecoin-Vault/#receive-hooks","text":"Payable functions when you send a payment to the contract with an appropriate message.","title":"Receive Hooks"},{"location":"Smart-Contracts/Stablecoin-Vault/#withdrawliquidity","text":"Attempt to withdraw deposits. Fees are calculated and deducted. If the Vault has available funds in Anchor it will attempt to payout the withdrawal request by first withdrawing some funds from Anchor to fund the withdrawal request. Luna holdings are not eligible for withdrawal. LP tokens submitted with a withdrawal request will be burned. The Treasury withdraw fee is paid out by transfering ownership of a fraction of the LP tokens to the treasury contract. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum Cw20HookMsg { WithdrawLiquidity {}, }","title":"WithdrawLiquidity"},{"location":"Smart-Contracts/Stablecoin-Vault/#callbacks","text":"Callback Functions are used in conjunction with other ExecuteMsg functions in the Stablecoin Vault.","title":"Callbacks"},{"location":"Smart-Contracts/Stablecoin-Vault/#aftersuccessfulloancallback","text":"After a successful loan happens, check if the contract currently holds more than the STABLE_CAP * 1.5. If it does, Leave STABLE_CAP in UST and deposit all other UST in Anchor. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum CallbackMsg { AfterSuccessfulLoanCallback {}, }","title":"AfterSuccessfulLoanCallback"},{"location":"Smart-Contracts/Stablecoin-Vault/#querymsg","text":"#[cfg_attr(not(feature = \"library\"), entry_point)] pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -> StdResult<Binary> { match msg { QueryMsg::PoolConfig {} => to_binary(&try_query_config(deps)?), QueryMsg::PoolState {} => to_binary(&try_query_pool_state(deps)?), QueryMsg::State {} => to_binary(&try_query_state(deps)?), QueryMsg::Fees {} => to_binary(&query_fees(deps)?), QueryMsg::VaultValue {} => to_binary(&query_total_value(deps)?), QueryMsg::EstimateWithdrawFee { amount } => { to_binary(&estimate_withdraw_fee(deps, amount)?) } } }","title":"QueryMsg"},{"location":"Smart-Contracts/Stablecoin-Vault/#state_1","text":"Returns the contract state. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { State {} }","title":"State"},{"location":"Smart-Contracts/Stablecoin-Vault/#vaultvalue","text":"Returns the total value of UST and aUST held in the contract in UST. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { VaultValue {} }","title":"VaultValue"},{"location":"Smart-Contracts/Stablecoin-Vault/#poolconfig","text":"Gets the configuration for the Stablecoin Vault contract pool. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { PoolConfig {} }","title":"PoolConfig"},{"location":"Smart-Contracts/Stablecoin-Vault/#poolinfo","text":"#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema)] pub struct PoolInfo { pub asset_infos: [AssetInfo; 2], pub contract_addr: Addr, pub liquidity_token: Addr, pub stable_cap: Uint128 } Key Type Description asset_infos [AssetInfo; 2] Collection of Assets in the Pool and their information. In our case UST and aUST contract_addr Addr This contract's address liquidity_token Addr Address of the LP token stable_cap Uint128 Stablecoin reserve/cap amount","title":"PoolInfo"},{"location":"Smart-Contracts/Stablecoin-Vault/#poolstate","text":"Gets the pool state, including the balances of the holdings. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { PoolState {} }","title":"PoolState"},{"location":"Smart-Contracts/Stablecoin-Vault/#poolresponse","text":"#[derive(Serialize, Deserialize, Clone, PartialEq, JsonSchema)] pub struct PoolResponse { pub asset_infos: [Asset; 2], pub contract_addr: Addr, pub liquidity_token: Addr, pub stable_cap: Uint128 } Key Type Description asset_infos [AssetInfo; 2] Collection of Assets in the Pool and their information. In our case UST and aUST contract_addr Addr This contract's address liquidity_token Addr Address of the LP token stable_cap Uint128 Stablecoin reserve/cap amount","title":"PoolResponse"},{"location":"Smart-Contracts/Stablecoin-Vault/#fees","text":"Gets the fees structure set by the Stablecoin Vault contract.","title":"Fees"},{"location":"Smart-Contracts/Stablecoin-Vault/#feeresponse","text":"pub struct FeeResponse { pub fees: VaultFee, }","title":"FeeResponse"},{"location":"Smart-Contracts/Stablecoin-Vault/#vaultfee","text":"Key Type Description flash_loan_fee Fee Flashloan fee expected to be paid by non-whitelisted contracts treasury_fee Fee Fee information related to Treasury fee distribution. treasury_addr CanonicalAddr Address of the Community Fund Contract","title":"VaultFee"},{"location":"Smart-Contracts/Stablecoin-Vault/#estimatewithdrawfee","text":"Query to provide an estimate of the Stablecoin Vault withdrawal fee minus tax. Key Type Description amount Uint128 Deposit amount to calculate a deposit fee for","title":"EstimateWithdrawFee"},{"location":"Smart-Contracts/Stablecoin-Vault/#estimatewithdrawfeeresponse","text":"pub struct EstimateWithdrawFeeResponse { pub fee: Vec<Coin>, } Key Type Description fee Vec Vector containing fee info in the form of Coins","title":"EstimateWithdrawFeeResponse"},{"location":"Smart-Contracts/Vesting/","text":"Vesting The vesting contract handles the WHALE vesting and lockup for the Investor and Team WHALE allocations. There is an important distiction between the vesting and unlocking schedules. The vesting schedule is the schedule that determines the WHALE token ownership transfers. The unlock schedule determines when the account can claim the tokens of which they have ownership. Config & State See config and state . Messages See vesting messages .","title":"Vesting"},{"location":"Smart-Contracts/Vesting/#vesting","text":"The vesting contract handles the WHALE vesting and lockup for the Investor and Team WHALE allocations. There is an important distiction between the vesting and unlocking schedules. The vesting schedule is the schedule that determines the WHALE token ownership transfers. The unlock schedule determines when the account can claim the tokens of which they have ownership.","title":"Vesting"},{"location":"Smart-Contracts/Vesting/#config-state","text":"See config and state .","title":"Config &amp; State"},{"location":"Smart-Contracts/Vesting/#messages","text":"See vesting messages .","title":"Messages"},{"location":"Smart-Contracts/tokenomics/Airdrop/","text":"Airdrop The Airdrop contract is for WHALE tokens airdrop claim during the intital protocol launch. This airdrop contract is based on the cw20-merkle-airdrop concept. Tools for working with cw20 Merkle Airdrops can be found here Config Key Type Description owner Option Address of owner/admin of the contract whale_token_address String Address of the WHALE token merkle_roots Option > Vector of merkle root proofs airdrop allocations from_timestamp Option When the airdrop will begin to_timestamp u64 When the airdrop will finish total_airdrop_size Uint128 Total amount of the airdrop Messages InstantiateMsg #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] pub struct InstantiateMsg { pub owner: Option<String>, pub whale_token_address: String, pub merkle_roots: Option<Vec<String>>, pub from_timestamp: Option<u64>, pub to_timestamp: u64, pub total_airdrop_size: Uint128, } Key Type Description owner Option Address of owner/admin of the contract whale_token_address String Address of the WHALE token merkle_roots Option > Vector of merkle root proofs airdrop allocations from_timestamp Option When the airdrop will begin to_timestamp u64 When the airdrop will finish total_airdrop_size Uint128 Total amount of the airdrop ExecuteMsg UpdateConfig Updates the stored configuration values for the contract. Callable only by an Admin. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { UpdateConfig { owner: Option<String>, merkle_roots: Option<Vec<String>>, from_timestamp: Option<u64>, to_timestamp: Option<u64>, }, } Claim Allows a given terra user to claim their WHALE airdrop. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { Claim { claim_amount: Uint128, merkle_proof: Vec<String>, root_index: u32, }, } TransferUnclaimedTokens Transfers remaining unclaimed $WHALE tokens. Callable only by an Admin. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { TransferUnclaimedTokens { recipient: String, amount: Uint128 }, } Key Type Description recipient String Reciver of the unclaimed tokens amount Uint128 Amount of airdrop tokens to transfer QueryMsg Config Gets the stored configuration information for the contract. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { Config {} } State Gets the stored state values for the contract. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { State {} } UserInfo Returns any stored UserInfo related to claiming if found in the merkle roots. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { UserInfo { address:String } } HasUserClaimed Return whether or not a given address has claimed. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { HasUserClaimed { address: String } }","title":"Airdrop"},{"location":"Smart-Contracts/tokenomics/Airdrop/#airdrop","text":"The Airdrop contract is for WHALE tokens airdrop claim during the intital protocol launch. This airdrop contract is based on the cw20-merkle-airdrop concept. Tools for working with cw20 Merkle Airdrops can be found here","title":"Airdrop"},{"location":"Smart-Contracts/tokenomics/Airdrop/#config","text":"Key Type Description owner Option Address of owner/admin of the contract whale_token_address String Address of the WHALE token merkle_roots Option > Vector of merkle root proofs airdrop allocations from_timestamp Option When the airdrop will begin to_timestamp u64 When the airdrop will finish total_airdrop_size Uint128 Total amount of the airdrop","title":"Config"},{"location":"Smart-Contracts/tokenomics/Airdrop/#messages","text":"","title":"Messages"},{"location":"Smart-Contracts/tokenomics/Airdrop/#instantiatemsg","text":"#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] pub struct InstantiateMsg { pub owner: Option<String>, pub whale_token_address: String, pub merkle_roots: Option<Vec<String>>, pub from_timestamp: Option<u64>, pub to_timestamp: u64, pub total_airdrop_size: Uint128, } Key Type Description owner Option Address of owner/admin of the contract whale_token_address String Address of the WHALE token merkle_roots Option > Vector of merkle root proofs airdrop allocations from_timestamp Option When the airdrop will begin to_timestamp u64 When the airdrop will finish total_airdrop_size Uint128 Total amount of the airdrop","title":"InstantiateMsg"},{"location":"Smart-Contracts/tokenomics/Airdrop/#executemsg","text":"","title":"ExecuteMsg"},{"location":"Smart-Contracts/tokenomics/Airdrop/#updateconfig","text":"Updates the stored configuration values for the contract. Callable only by an Admin. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { UpdateConfig { owner: Option<String>, merkle_roots: Option<Vec<String>>, from_timestamp: Option<u64>, to_timestamp: Option<u64>, }, }","title":"UpdateConfig"},{"location":"Smart-Contracts/tokenomics/Airdrop/#claim","text":"Allows a given terra user to claim their WHALE airdrop. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { Claim { claim_amount: Uint128, merkle_proof: Vec<String>, root_index: u32, }, }","title":"Claim"},{"location":"Smart-Contracts/tokenomics/Airdrop/#transferunclaimedtokens","text":"Transfers remaining unclaimed $WHALE tokens. Callable only by an Admin. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { TransferUnclaimedTokens { recipient: String, amount: Uint128 }, } Key Type Description recipient String Reciver of the unclaimed tokens amount Uint128 Amount of airdrop tokens to transfer","title":"TransferUnclaimedTokens"},{"location":"Smart-Contracts/tokenomics/Airdrop/#querymsg","text":"","title":"QueryMsg"},{"location":"Smart-Contracts/tokenomics/Airdrop/#config_1","text":"Gets the stored configuration information for the contract. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { Config {} }","title":"Config"},{"location":"Smart-Contracts/tokenomics/Airdrop/#state","text":"Gets the stored state values for the contract. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { State {} }","title":"State"},{"location":"Smart-Contracts/tokenomics/Airdrop/#userinfo","text":"Returns any stored UserInfo related to claiming if found in the merkle roots. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { UserInfo { address:String } }","title":"UserInfo"},{"location":"Smart-Contracts/tokenomics/Airdrop/#hasuserclaimed","text":"Return whether or not a given address has claimed. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { HasUserClaimed { address: String } }","title":"HasUserClaimed"},{"location":"Smart-Contracts/tokenomics/LP-Emissions-Proxy/","text":"LP Emissions Proxy Contract This proxy contract handles staking the provided LP tokens to our own LP emissions contract while allowing for dual incetives from Astroport. A detailed explanation can be found here Config Key Type Description generator_contract_addr Addr Address of generator contract pair_addr Addr Address of the WHALE/UST pair lp_token_addr Addr Address of the WHALE/UST LP token reward_contract_addr Addr Address of the LP emissions contract reward_token_addr Addr Whale token address Messages InstantiateMsg #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] pub struct InstantiateMsg { pub generator_contract_addr: String, pub pair_addr: String, pub lp_token_addr: String, pub reward_contract_addr: String, pub reward_token_addr: String, } Key Type Description generator_contract_addr String Address of generator contract pair_addr String Address of the WHALE/UST pair lp_token_addr String Address of the WHALE/UST LP token reward_contract_addr String Address of the LP emissions contract reward_token_addr String Whale token address ExecuteMsg Receive Receives LP tokens sent by Generator contract. Further sends them to the $WHALE LP Staking contract #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { Recieve(Cw20ReceiveMsg), } UpdateRewards Claims pending rewards from the $WHALE LP staking contract #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { UpdateRewards {}, } SendRewards Transfers $WHALE rewards #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { SendRewards { account: Addr, amount: Uint128 }, } Key Type Description account Addr Address of the LP staker amount Uint128 Amount of reward tokens to transfer Withdraw Withdraws LP Tokens from the staking contract. Rewards are NOT claimed when withdrawing LP tokens #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { Withdraw { account: Addr, amount: Uint128 }, } Key Type Description account Addr Address of the LP staker amount Uint128 Amount of reward tokens to transfer EmergencyWithdraw Withdraws LP Tokens from the staking contract. Rewards are NOT claimed when withdrawing LP tokens. Uses same withdraw function internally. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { EmergencyWithdraw { account: Addr, amount: Uint128 }, } Key Type Description account Addr Address of the LP staker amount Uint128 Amount of reward tokens to transfer QueryMsg Deposit Gets the bonded amount of LP tokens #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { Deposit {} } Reward Returns the amount of WHALE held by this contract. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { Reward {} } PendingToken Returns the claimable amount of WHALE. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { PendingToken {} } RewardInfo Return the WHALE token address. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { RewardInfo {} }","title":"LP Emissions Proxy Contract"},{"location":"Smart-Contracts/tokenomics/LP-Emissions-Proxy/#lp-emissions-proxy-contract","text":"This proxy contract handles staking the provided LP tokens to our own LP emissions contract while allowing for dual incetives from Astroport. A detailed explanation can be found here","title":"LP Emissions Proxy Contract"},{"location":"Smart-Contracts/tokenomics/LP-Emissions-Proxy/#config","text":"Key Type Description generator_contract_addr Addr Address of generator contract pair_addr Addr Address of the WHALE/UST pair lp_token_addr Addr Address of the WHALE/UST LP token reward_contract_addr Addr Address of the LP emissions contract reward_token_addr Addr Whale token address","title":"Config"},{"location":"Smart-Contracts/tokenomics/LP-Emissions-Proxy/#messages","text":"","title":"Messages"},{"location":"Smart-Contracts/tokenomics/LP-Emissions-Proxy/#instantiatemsg","text":"#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] pub struct InstantiateMsg { pub generator_contract_addr: String, pub pair_addr: String, pub lp_token_addr: String, pub reward_contract_addr: String, pub reward_token_addr: String, } Key Type Description generator_contract_addr String Address of generator contract pair_addr String Address of the WHALE/UST pair lp_token_addr String Address of the WHALE/UST LP token reward_contract_addr String Address of the LP emissions contract reward_token_addr String Whale token address","title":"InstantiateMsg"},{"location":"Smart-Contracts/tokenomics/LP-Emissions-Proxy/#executemsg","text":"","title":"ExecuteMsg"},{"location":"Smart-Contracts/tokenomics/LP-Emissions-Proxy/#receive","text":"Receives LP tokens sent by Generator contract. Further sends them to the $WHALE LP Staking contract #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { Recieve(Cw20ReceiveMsg), }","title":"Receive"},{"location":"Smart-Contracts/tokenomics/LP-Emissions-Proxy/#updaterewards","text":"Claims pending rewards from the $WHALE LP staking contract #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { UpdateRewards {}, }","title":"UpdateRewards"},{"location":"Smart-Contracts/tokenomics/LP-Emissions-Proxy/#sendrewards","text":"Transfers $WHALE rewards #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { SendRewards { account: Addr, amount: Uint128 }, } Key Type Description account Addr Address of the LP staker amount Uint128 Amount of reward tokens to transfer","title":"SendRewards"},{"location":"Smart-Contracts/tokenomics/LP-Emissions-Proxy/#withdraw","text":"Withdraws LP Tokens from the staking contract. Rewards are NOT claimed when withdrawing LP tokens #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { Withdraw { account: Addr, amount: Uint128 }, } Key Type Description account Addr Address of the LP staker amount Uint128 Amount of reward tokens to transfer","title":"Withdraw"},{"location":"Smart-Contracts/tokenomics/LP-Emissions-Proxy/#emergencywithdraw","text":"Withdraws LP Tokens from the staking contract. Rewards are NOT claimed when withdrawing LP tokens. Uses same withdraw function internally. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum ExecuteMsg { EmergencyWithdraw { account: Addr, amount: Uint128 }, } Key Type Description account Addr Address of the LP staker amount Uint128 Amount of reward tokens to transfer","title":"EmergencyWithdraw"},{"location":"Smart-Contracts/tokenomics/LP-Emissions-Proxy/#querymsg","text":"","title":"QueryMsg"},{"location":"Smart-Contracts/tokenomics/LP-Emissions-Proxy/#deposit","text":"Gets the bonded amount of LP tokens #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { Deposit {} }","title":"Deposit"},{"location":"Smart-Contracts/tokenomics/LP-Emissions-Proxy/#reward","text":"Returns the amount of WHALE held by this contract. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { Reward {} }","title":"Reward"},{"location":"Smart-Contracts/tokenomics/LP-Emissions-Proxy/#pendingtoken","text":"Returns the claimable amount of WHALE. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { PendingToken {} }","title":"PendingToken"},{"location":"Smart-Contracts/tokenomics/LP-Emissions-Proxy/#rewardinfo","text":"Return the WHALE token address. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum QueryMsg { RewardInfo {} }","title":"RewardInfo"},{"location":"Smart-Contracts/tokenomics/LP-Emissions/","text":"LP Emissions Contract This contract handles liquidity mining incetives. It distributes WHALE tokens to WHALE/UST LP token stakers who can claim then claim them. Config Key Type Description owner Addr Address of the owner of the contract whale_token Addr Address of the WHALE token staking_token Addr Address of the WHALE/UST staking token staking_token_decimals u8 distribution_schedule (u64,u64,Uint128) The distribution schedule parameters State Key Type Description last_distributed u64 Timestamp at which the global_reward_index was last updated total_bond_amount Uint128 Total number of WHALE-UST LP tokens staked with the contract global_reward_index Decimal Used to calculate WHALE rewards accured over time elapsed. Ratio = Total distributed WHALE tokens / total bond amount leftover Uint128 Number of WHALE tokens that are yet to be distributed reward_rate_per_token Decimal Number of WHALE tokens distributed per staked LP token Messages See lp_emissions messages .","title":"LP Emissions Contract"},{"location":"Smart-Contracts/tokenomics/LP-Emissions/#lp-emissions-contract","text":"This contract handles liquidity mining incetives. It distributes WHALE tokens to WHALE/UST LP token stakers who can claim then claim them.","title":"LP Emissions Contract"},{"location":"Smart-Contracts/tokenomics/LP-Emissions/#config","text":"Key Type Description owner Addr Address of the owner of the contract whale_token Addr Address of the WHALE token staking_token Addr Address of the WHALE/UST staking token staking_token_decimals u8 distribution_schedule (u64,u64,Uint128) The distribution schedule parameters","title":"Config"},{"location":"Smart-Contracts/tokenomics/LP-Emissions/#state","text":"Key Type Description last_distributed u64 Timestamp at which the global_reward_index was last updated total_bond_amount Uint128 Total number of WHALE-UST LP tokens staked with the contract global_reward_index Decimal Used to calculate WHALE rewards accured over time elapsed. Ratio = Total distributed WHALE tokens / total bond amount leftover Uint128 Number of WHALE tokens that are yet to be distributed reward_rate_per_token Decimal Number of WHALE tokens distributed per staked LP token","title":"State"},{"location":"Smart-Contracts/tokenomics/LP-Emissions/#messages","text":"See lp_emissions messages .","title":"Messages"},{"location":"Smart-Contracts/treasury/memory/","text":"Memory The memory contract represents an abstraction around the use and storage of contract and asset addresses. The contract has two internal maps and provided two types of Raw query calls. These are methods implemented in the Memory struct. With this request-response model around addresses and assets we gain a small piece of assurance against human error such as mistyped addresses as well as gaining the ability to have many dapps requesting asset info from a common source. We are working with external public partners to enshure the registered addresses are correct. Config BaseState See Dapp BaseState InstantiateMsg No values are needed to instantiate this contract. The sender of the instantiate msg will be marked as the Admin. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub struct InstantiateMsg {} ExecuteMsg pub enum ExecuteMsg { /// Updates the addressbook UpdateContractAddresses { to_add: Vec<(String, String)>, to_remove: Vec<String>, }, UpdateAssetAddresses { to_add: Vec<(String, String)>, to_remove: Vec<String>, }, /// Sets a new Admin SetAdmin { admin: String }, } SetAdmin Update the configured admin for the memory contract. Key Type Description admin String Address of the new Admin. { \"set_admin\": { \"admin\": \"terra1...\" } } UpdateContractAddresses Attempt to add and/or remove 1 or more contract address from the memory contract. This call can be used to store contracts one by one or in one go to store many contracts on instantiation of a Dapp. Name Type Description to_add Vec<(String, String)> Vector containing a pair mapping for each contract address to be added. to_remove Vec<(String)> Vector containing memory keys/ids for each contract address to be removed from Memory. { \"update_contract_addresses\": { \"to_add\": [(\"mykey\", \"terra1...\")], \"to_remove\": [\"key_to_remove\"] } } UpdateContractAssets Attempt to add and/or remove 1 or more Asset types from the memory contract. This call can be used to store Assets which will be used by the Dapp such as storing a custom CW20 including its address ready for later use. Name Type Description to_add Vec<(String, String)> Vector containing a pair mapping for each Asset to be added. to_remove Vec<(String)> Vector containing memory keys/ids for each Asset to be removed from Memory. { \"update_contract_assets\": { \"to_add\": [(\"asset_key\", \"asset_1\")], \"to_remove\": [\"key_to_remove\"] } } QueryMsg pub enum QueryMsg { /// Queries assets based on name QueryAssets { names: Vec<String>, }, QueryContracts { names: Vec<String>, }, }","title":"Memory"},{"location":"Smart-Contracts/treasury/memory/#memory","text":"The memory contract represents an abstraction around the use and storage of contract and asset addresses. The contract has two internal maps and provided two types of Raw query calls. These are methods implemented in the Memory struct. With this request-response model around addresses and assets we gain a small piece of assurance against human error such as mistyped addresses as well as gaining the ability to have many dapps requesting asset info from a common source. We are working with external public partners to enshure the registered addresses are correct.","title":"Memory"},{"location":"Smart-Contracts/treasury/memory/#config","text":"","title":"Config"},{"location":"Smart-Contracts/treasury/memory/#basestate","text":"See Dapp BaseState","title":"BaseState"},{"location":"Smart-Contracts/treasury/memory/#instantiatemsg","text":"No values are needed to instantiate this contract. The sender of the instantiate msg will be marked as the Admin. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub struct InstantiateMsg {}","title":"InstantiateMsg"},{"location":"Smart-Contracts/treasury/memory/#executemsg","text":"pub enum ExecuteMsg { /// Updates the addressbook UpdateContractAddresses { to_add: Vec<(String, String)>, to_remove: Vec<String>, }, UpdateAssetAddresses { to_add: Vec<(String, String)>, to_remove: Vec<String>, }, /// Sets a new Admin SetAdmin { admin: String }, }","title":"ExecuteMsg"},{"location":"Smart-Contracts/treasury/memory/#setadmin","text":"Update the configured admin for the memory contract. Key Type Description admin String Address of the new Admin. { \"set_admin\": { \"admin\": \"terra1...\" } }","title":"SetAdmin"},{"location":"Smart-Contracts/treasury/memory/#updatecontractaddresses","text":"Attempt to add and/or remove 1 or more contract address from the memory contract. This call can be used to store contracts one by one or in one go to store many contracts on instantiation of a Dapp. Name Type Description to_add Vec<(String, String)> Vector containing a pair mapping for each contract address to be added. to_remove Vec<(String)> Vector containing memory keys/ids for each contract address to be removed from Memory. { \"update_contract_addresses\": { \"to_add\": [(\"mykey\", \"terra1...\")], \"to_remove\": [\"key_to_remove\"] } }","title":"UpdateContractAddresses"},{"location":"Smart-Contracts/treasury/memory/#updatecontractassets","text":"Attempt to add and/or remove 1 or more Asset types from the memory contract. This call can be used to store Assets which will be used by the Dapp such as storing a custom CW20 including its address ready for later use. Name Type Description to_add Vec<(String, String)> Vector containing a pair mapping for each Asset to be added. to_remove Vec<(String)> Vector containing memory keys/ids for each Asset to be removed from Memory. { \"update_contract_assets\": { \"to_add\": [(\"asset_key\", \"asset_1\")], \"to_remove\": [\"key_to_remove\"] } }","title":"UpdateContractAssets"},{"location":"Smart-Contracts/treasury/memory/#querymsg","text":"pub enum QueryMsg { /// Queries assets based on name QueryAssets { names: Vec<String>, }, QueryContracts { names: Vec<String>, }, }","title":"QueryMsg"},{"location":"Smart-Contracts/treasury/treasury/","text":"Treasury The Treasury contract is the holder of the Protocol Owned Liquidity and is able to maintain a series of registered helper smart contracts, which we call 'dapps', to prepare messages for various operations. Only whitelisted addresses are able to forward messages for execution. The treasury also has internal value calculation logic. This logic is enable by the VaultAsset class in which each VaultAsset, apart from the base reference (UST for example), has a value reference (ValueRef). The value reference provides a way to calculate the value of the asset held in the treasury given a correct configuration. Config Name Type Description InstantiateMsg #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] pub struct InstantiateMsg { } Name Type Description ExecuteMsg pub enum ExecuteMsg { /// Sets the admin SetAdmin { admin: String }, /// Executes the provided messages if sender is whitelisted DAppAction { msgs: Vec<CosmosMsg<Empty>> }, /// Adds the provided address to whitelisted dapps AddDApp { dapp: String }, /// Removes the provided address from the whitelisted dapps RemoveDApp { dapp: String }, /// Updates the VAULT_ASSETS map UpdateAssets { to_add: Vec<VaultAsset>, to_remove: Vec<AssetInfo>, }, } SetAdmin Updates the Treasury contract admin. Note: The AdminResponse object is imported from the cw_controllers package. This definition may change as that package is updated { \"set_admin\": { \"admin\": \"terra1...\" } } Name Type Description admin String Address of the new contract admin AddDApp Registers a contract address as a registered Dapp { \"add_d_app\": { \"dapp\": \"terra1...\" } } Name Type Description dapp String Address of the dapp to register. RemoveDApp Deregistered an already registered Dapp using its contract address. { \"remove_d_app\": { \"dapp\": \"terra1...\" } } Name Type Description dapp String Address of the registered dapp to remove DappAction Take one or more msgs as a vec and then attempt to execute these actions on behalf of a whitelisted address. { \"d_app_action\": { \"msgs\": [] } } Name Type Description msg Vec[CosmosMsg[Empty]] Vector of msgs to be executed UpdateAssets Update the stored asset information for the treasury. This information is only used to calculate the treasury holding value. { \"update_assets\": { \"to_add\": [ {\"asset\":{ \"info\": { \"native_token\": {\"denom\": \"uusd\"} }, \"amount\": \"0\" }, \"value_reference\": null } ], \"to_remove\": [{\"denom\":\"uusd\"}] } } Name Type Description to_add Vec[VaultAsset] Vector of assets to be added to_remove Vec[AssetInfo] Vector of asset infos to be removed QueryMsg pub enum QueryMsg { /// Returns the treasury Config Config {}, /// Returns the total value of all held assets TotalValue {}, /// Returns the value of one specific asset HoldingValue { identifier: String }, /// Returns the amount of specified tokens this contract holds HoldingAmount { identifier: String }, /// Returns the VAULT_ASSETS value for the specified key VaultAssetConfig { identifier: String }, } Config Returns all the permissioned dapps { \"config\": {} } Name Type Description ConfigResponse #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] pub struct ConfigResponse { pub dapps: Vec<String>, } { \"dapps\": [], } Name Type Description dapps Vec Vec containing a list of registered dapps TotalValue Gets the total value of assets in the Treasury. { \"total_value\": {} } Name Type Description TotalValueResponse #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema, Debug)] pub struct TotalValueResponse { value: Uint128 } { } Name Type Description HoldingValue Computes and returns the value of a specified asset that is held by the vault. { \"holding_value\": { \"identifier\": \"terra1dfs...\" } } Name Type Description HoldingValueResponse #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema, Debug)] pub struct HoldingValueResponse { value: Uint128 } { \"value\": \"...\", } Name Type Description HoldingAmount Returns the amount of a specified asset that is held by the vault. { \"holding_value\": { \"identifier\": \"terra1dfs...\" } } Name Type Description VaultAssetConfig Returns the registered Assets of the treasury vault. { \"vault_asset_config\": { \"identifier\": \"terra1dfs...\" } } Name Type Description","title":"Treasury"},{"location":"Smart-Contracts/treasury/treasury/#treasury","text":"The Treasury contract is the holder of the Protocol Owned Liquidity and is able to maintain a series of registered helper smart contracts, which we call 'dapps', to prepare messages for various operations. Only whitelisted addresses are able to forward messages for execution. The treasury also has internal value calculation logic. This logic is enable by the VaultAsset class in which each VaultAsset, apart from the base reference (UST for example), has a value reference (ValueRef). The value reference provides a way to calculate the value of the asset held in the treasury given a correct configuration.","title":"Treasury"},{"location":"Smart-Contracts/treasury/treasury/#config","text":"Name Type Description","title":"Config"},{"location":"Smart-Contracts/treasury/treasury/#instantiatemsg","text":"#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] pub struct InstantiateMsg { } Name Type Description","title":"InstantiateMsg"},{"location":"Smart-Contracts/treasury/treasury/#executemsg","text":"pub enum ExecuteMsg { /// Sets the admin SetAdmin { admin: String }, /// Executes the provided messages if sender is whitelisted DAppAction { msgs: Vec<CosmosMsg<Empty>> }, /// Adds the provided address to whitelisted dapps AddDApp { dapp: String }, /// Removes the provided address from the whitelisted dapps RemoveDApp { dapp: String }, /// Updates the VAULT_ASSETS map UpdateAssets { to_add: Vec<VaultAsset>, to_remove: Vec<AssetInfo>, }, }","title":"ExecuteMsg"},{"location":"Smart-Contracts/treasury/treasury/#setadmin","text":"Updates the Treasury contract admin. Note: The AdminResponse object is imported from the cw_controllers package. This definition may change as that package is updated { \"set_admin\": { \"admin\": \"terra1...\" } } Name Type Description admin String Address of the new contract admin","title":"SetAdmin"},{"location":"Smart-Contracts/treasury/treasury/#adddapp","text":"Registers a contract address as a registered Dapp { \"add_d_app\": { \"dapp\": \"terra1...\" } } Name Type Description dapp String Address of the dapp to register.","title":"AddDApp"},{"location":"Smart-Contracts/treasury/treasury/#removedapp","text":"Deregistered an already registered Dapp using its contract address. { \"remove_d_app\": { \"dapp\": \"terra1...\" } } Name Type Description dapp String Address of the registered dapp to remove","title":"RemoveDApp"},{"location":"Smart-Contracts/treasury/treasury/#dappaction","text":"Take one or more msgs as a vec and then attempt to execute these actions on behalf of a whitelisted address. { \"d_app_action\": { \"msgs\": [] } } Name Type Description msg Vec[CosmosMsg[Empty]] Vector of msgs to be executed","title":"DappAction"},{"location":"Smart-Contracts/treasury/treasury/#updateassets","text":"Update the stored asset information for the treasury. This information is only used to calculate the treasury holding value. { \"update_assets\": { \"to_add\": [ {\"asset\":{ \"info\": { \"native_token\": {\"denom\": \"uusd\"} }, \"amount\": \"0\" }, \"value_reference\": null } ], \"to_remove\": [{\"denom\":\"uusd\"}] } } Name Type Description to_add Vec[VaultAsset] Vector of assets to be added to_remove Vec[AssetInfo] Vector of asset infos to be removed","title":"UpdateAssets"},{"location":"Smart-Contracts/treasury/treasury/#querymsg","text":"pub enum QueryMsg { /// Returns the treasury Config Config {}, /// Returns the total value of all held assets TotalValue {}, /// Returns the value of one specific asset HoldingValue { identifier: String }, /// Returns the amount of specified tokens this contract holds HoldingAmount { identifier: String }, /// Returns the VAULT_ASSETS value for the specified key VaultAssetConfig { identifier: String }, }","title":"QueryMsg"},{"location":"Smart-Contracts/treasury/treasury/#config_1","text":"Returns all the permissioned dapps { \"config\": {} } Name Type Description","title":"Config"},{"location":"Smart-Contracts/treasury/treasury/#configresponse","text":"#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] pub struct ConfigResponse { pub dapps: Vec<String>, } { \"dapps\": [], } Name Type Description dapps Vec Vec containing a list of registered dapps","title":"ConfigResponse"},{"location":"Smart-Contracts/treasury/treasury/#totalvalue","text":"Gets the total value of assets in the Treasury. { \"total_value\": {} } Name Type Description","title":"TotalValue"},{"location":"Smart-Contracts/treasury/treasury/#totalvalueresponse","text":"#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema, Debug)] pub struct TotalValueResponse { value: Uint128 } { } Name Type Description","title":"TotalValueResponse"},{"location":"Smart-Contracts/treasury/treasury/#holdingvalue","text":"Computes and returns the value of a specified asset that is held by the vault. { \"holding_value\": { \"identifier\": \"terra1dfs...\" } } Name Type Description","title":"HoldingValue"},{"location":"Smart-Contracts/treasury/treasury/#holdingvalueresponse","text":"#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema, Debug)] pub struct HoldingValueResponse { value: Uint128 } { \"value\": \"...\", } Name Type Description","title":"HoldingValueResponse"},{"location":"Smart-Contracts/treasury/treasury/#holdingamount","text":"Returns the amount of a specified asset that is held by the vault. { \"holding_value\": { \"identifier\": \"terra1dfs...\" } } Name Type Description","title":"HoldingAmount"},{"location":"Smart-Contracts/treasury/treasury/#vaultassetconfig","text":"Returns the registered Assets of the treasury vault. { \"vault_asset_config\": { \"identifier\": \"terra1dfs...\" } } Name Type Description","title":"VaultAssetConfig"},{"location":"Smart-Contracts/treasury/dapps/Anchor-dapp/","text":"Anchor Dapp Config This dapps config is composed of two state objects. A BaseState which every dapp have and an optionally used State for any Dapp-specific config values BaseState See Dapp Base State Name Type Description InstantiateMsg See Dapp BaseInstantiateMsg ExecuteMsg #[cfg_attr(not(feature = \"library\"), entry_point)] pub fn execute(deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg) -> BaseDAppResult { match msg { ExecuteMsg::Base(message) => dapp_base_commands::handle_base_message(deps, info, message), // handle dapp-specific messages here // ExecuteMsg::Custom{} => commands::custom_command(), ExecuteMsg::DepositStable { deposit_amount } => { commands::handle_deposit_stable(deps.as_ref(), env, info, deposit_amount) } ExecuteMsg::RedeemStable { withdraw_amount } => { commands::handle_redeem_stable(deps.as_ref(), env, info, withdraw_amount) } } } DepositStable Attempt to deposit an amount of UST into Anchor on behalf of the Treasury. Key Type Description ust_deposit_amount Uint128 Amount of UST to be deposited into Anchor. { \"deposit_stable\": { \"ust_deposit_amount\": \"1000...\" } RedeemStable Attempt to withdraw an amount of UST into Anchor on behalf of the Treasury. Key Type Description ust_to_withdraw Uint128 Amount of UST to be withdrawn from Anchor. { \"redeem_stable\": { \"ust_to_withdraw\": \"1000...\" } QueryMsg #[cfg_attr(not(feature = \"library\"), entry_point)] pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -> StdResult<Binary> { match msg { QueryMsg::Base(message) => dapp_base_queries::handle_base_query(deps, message), // handle dapp-specific queries here // QueryMsg::Custom{} => queries::custom_query(), } }","title":"Anchor Dapp"},{"location":"Smart-Contracts/treasury/dapps/Anchor-dapp/#anchor-dapp","text":"","title":"Anchor Dapp"},{"location":"Smart-Contracts/treasury/dapps/Anchor-dapp/#config","text":"This dapps config is composed of two state objects. A BaseState which every dapp have and an optionally used State for any Dapp-specific config values","title":"Config"},{"location":"Smart-Contracts/treasury/dapps/Anchor-dapp/#basestate","text":"See Dapp Base","title":"BaseState"},{"location":"Smart-Contracts/treasury/dapps/Anchor-dapp/#state","text":"Name Type Description","title":"State"},{"location":"Smart-Contracts/treasury/dapps/Anchor-dapp/#instantiatemsg","text":"See Dapp BaseInstantiateMsg","title":"InstantiateMsg"},{"location":"Smart-Contracts/treasury/dapps/Anchor-dapp/#executemsg","text":"#[cfg_attr(not(feature = \"library\"), entry_point)] pub fn execute(deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg) -> BaseDAppResult { match msg { ExecuteMsg::Base(message) => dapp_base_commands::handle_base_message(deps, info, message), // handle dapp-specific messages here // ExecuteMsg::Custom{} => commands::custom_command(), ExecuteMsg::DepositStable { deposit_amount } => { commands::handle_deposit_stable(deps.as_ref(), env, info, deposit_amount) } ExecuteMsg::RedeemStable { withdraw_amount } => { commands::handle_redeem_stable(deps.as_ref(), env, info, withdraw_amount) } } }","title":"ExecuteMsg"},{"location":"Smart-Contracts/treasury/dapps/Anchor-dapp/#depositstable","text":"Attempt to deposit an amount of UST into Anchor on behalf of the Treasury. Key Type Description ust_deposit_amount Uint128 Amount of UST to be deposited into Anchor. { \"deposit_stable\": { \"ust_deposit_amount\": \"1000...\" }","title":"DepositStable"},{"location":"Smart-Contracts/treasury/dapps/Anchor-dapp/#redeemstable","text":"Attempt to withdraw an amount of UST into Anchor on behalf of the Treasury. Key Type Description ust_to_withdraw Uint128 Amount of UST to be withdrawn from Anchor. { \"redeem_stable\": { \"ust_to_withdraw\": \"1000...\" }","title":"RedeemStable"},{"location":"Smart-Contracts/treasury/dapps/Anchor-dapp/#querymsg","text":"#[cfg_attr(not(feature = \"library\"), entry_point)] pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -> StdResult<Binary> { match msg { QueryMsg::Base(message) => dapp_base_queries::handle_base_query(deps, message), // handle dapp-specific queries here // QueryMsg::Custom{} => queries::custom_query(), } }","title":"QueryMsg"},{"location":"Smart-Contracts/treasury/dapps/Astroport-Dapp/","text":"Astroport Dapp Config BaseState See Dapp BaseState InstantiateMsg See Dapp BaseInstantiateMsg ExecuteMsg #[cfg_attr(not(feature = \"library\"), entry_point)] pub fn execute(deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg) -> AstroportResult { match msg { ExecuteMsg::ProvideLiquidity { pool_id, main_asset_id, amount, } => commands::provide_liquidity(deps.as_ref(), info, main_asset_id, pool_id, amount), ExecuteMsg::DetailedProvideLiquidity { pool_id, assets, slippage_tolerance, } => commands::detailed_provide_liquidity( deps.as_ref(), info, assets, pool_id, slippage_tolerance, ), ExecuteMsg::WithdrawLiquidity { lp_token_id, amount, } => commands::withdraw_liquidity(deps.as_ref(), info, lp_token_id, amount), ExecuteMsg::SwapAsset { offer_id, pool_id, amount, max_spread, belief_price, } => commands::astroport_swap( deps.as_ref(), env, info, offer_id, pool_id, amount, max_spread, belief_price, ), ExecuteMsg::Base(message) => { from_base_dapp_result(dapp_base_commands::handle_base_message(deps, info, message)) } } } Base See handle_base_message in Dapp Base ProvideLiquidity An abstraction around liquidity provision for Terraswap. Rather than specifying the contract addresses and asset structures, the caller provides a referential ID for the relevant contract addresses which have been stored in the contracts associated Memory contract. After the message is composed it is sent to the treasury for execution. The contract fetches what other asset is paired with the main_asset in the provided pool and adds that to the pool at the current ratio of the pool. Key Type Description pool_id String The reference name for the stored pool contract. Every trading pair ends with \"_pair\" main_asset_id String The reference name for the stored Asset to be used as the 'main' Asset amount UInt128 The amount of the specified main asset to be added to the pool { \"provide_liquidity\": { \"pool_id\": \"whale_ust_pair\", \"main_asset_id\": \"ust\", \"amount\": \"10000\" } DetailedProvideLiquidity Similar to ProvideLiquidity but with the ability to specify both asset amounts to be added and with what amount of slippage. Rather than specifying the contract addresses and asset structures, the caller provides a referential ID for the relevant contract addresses which have been stored in the contracts associated Memory contract. After the message is composed it is sent to the treasury for execution. Key Type Description pool_id String The reference name for the stored pool contract. assets Vec[String] Vector containing 2 asset reference names. slippage_tolerance Option[Decimal] The maximum amount of slippage considered acceptable. { \"detailed_provide_liquidity\": { \"pool_id\": \"whale_ust\", \"assets\": [\"stored_ust\", \"stored_krt\"], \"slippage_tolerance\": null } WithdrawLiquidity Composes a message to withdraw liquidity by returning an amount of the LP token received on liquidity provision. The message is then sent to the treasury for execution. Key Type Description lp_token_id String The reference name for the stored liquidity token contract. amount UInt128 The amount of lp tokens to be sent { \"withdraw_liquidity\": { \"lp_token_id\": \"whale_ust\", \"amount\": \"100000\", } SwapAsset ExecuteMsg used to compose a swap message for Terraswap which is then send to the Treasury for execution. Key Type Description offer_id String The reference name for the offered Asset's info. pool_id String The reference name for the stored pool contract. amount UInt128 The offer asset amount max_spread Option The maximum amount of spread considered acceptable. belief_price Option The current user-provided price for the token. When provided, max_spread is used to determine whether the trade is acceptable. { \"swap_asset\": { \"offer_id\": \"my_offer\", \"pool_id\": \"whale_ust\", \"amount\": \"100000\", \"max_spread\": null, \"slippage_tolerance\": null } QueryMsg #[cfg_attr(not(feature = \"library\"), entry_point)] pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -> StdResult<Binary> { match msg { QueryMsg::Base(message) => dapp_base_queries::handle_base_query(deps, message), } } Base See handle_base_query in Dapp Base","title":"Astroport Dapp"},{"location":"Smart-Contracts/treasury/dapps/Astroport-Dapp/#astroport-dapp","text":"","title":"Astroport Dapp"},{"location":"Smart-Contracts/treasury/dapps/Astroport-Dapp/#config","text":"","title":"Config"},{"location":"Smart-Contracts/treasury/dapps/Astroport-Dapp/#basestate","text":"See Dapp BaseState","title":"BaseState"},{"location":"Smart-Contracts/treasury/dapps/Astroport-Dapp/#instantiatemsg","text":"See Dapp BaseInstantiateMsg","title":"InstantiateMsg"},{"location":"Smart-Contracts/treasury/dapps/Astroport-Dapp/#executemsg","text":"#[cfg_attr(not(feature = \"library\"), entry_point)] pub fn execute(deps: DepsMut, env: Env, info: MessageInfo, msg: ExecuteMsg) -> AstroportResult { match msg { ExecuteMsg::ProvideLiquidity { pool_id, main_asset_id, amount, } => commands::provide_liquidity(deps.as_ref(), info, main_asset_id, pool_id, amount), ExecuteMsg::DetailedProvideLiquidity { pool_id, assets, slippage_tolerance, } => commands::detailed_provide_liquidity( deps.as_ref(), info, assets, pool_id, slippage_tolerance, ), ExecuteMsg::WithdrawLiquidity { lp_token_id, amount, } => commands::withdraw_liquidity(deps.as_ref(), info, lp_token_id, amount), ExecuteMsg::SwapAsset { offer_id, pool_id, amount, max_spread, belief_price, } => commands::astroport_swap( deps.as_ref(), env, info, offer_id, pool_id, amount, max_spread, belief_price, ), ExecuteMsg::Base(message) => { from_base_dapp_result(dapp_base_commands::handle_base_message(deps, info, message)) } } }","title":"ExecuteMsg"},{"location":"Smart-Contracts/treasury/dapps/Astroport-Dapp/#base","text":"See handle_base_message in Dapp Base","title":"Base"},{"location":"Smart-Contracts/treasury/dapps/Astroport-Dapp/#provideliquidity","text":"An abstraction around liquidity provision for Terraswap. Rather than specifying the contract addresses and asset structures, the caller provides a referential ID for the relevant contract addresses which have been stored in the contracts associated Memory contract. After the message is composed it is sent to the treasury for execution. The contract fetches what other asset is paired with the main_asset in the provided pool and adds that to the pool at the current ratio of the pool. Key Type Description pool_id String The reference name for the stored pool contract. Every trading pair ends with \"_pair\" main_asset_id String The reference name for the stored Asset to be used as the 'main' Asset amount UInt128 The amount of the specified main asset to be added to the pool { \"provide_liquidity\": { \"pool_id\": \"whale_ust_pair\", \"main_asset_id\": \"ust\", \"amount\": \"10000\" }","title":"ProvideLiquidity"},{"location":"Smart-Contracts/treasury/dapps/Astroport-Dapp/#detailedprovideliquidity","text":"Similar to ProvideLiquidity but with the ability to specify both asset amounts to be added and with what amount of slippage. Rather than specifying the contract addresses and asset structures, the caller provides a referential ID for the relevant contract addresses which have been stored in the contracts associated Memory contract. After the message is composed it is sent to the treasury for execution. Key Type Description pool_id String The reference name for the stored pool contract. assets Vec[String] Vector containing 2 asset reference names. slippage_tolerance Option[Decimal] The maximum amount of slippage considered acceptable. { \"detailed_provide_liquidity\": { \"pool_id\": \"whale_ust\", \"assets\": [\"stored_ust\", \"stored_krt\"], \"slippage_tolerance\": null }","title":"DetailedProvideLiquidity"},{"location":"Smart-Contracts/treasury/dapps/Astroport-Dapp/#withdrawliquidity","text":"Composes a message to withdraw liquidity by returning an amount of the LP token received on liquidity provision. The message is then sent to the treasury for execution. Key Type Description lp_token_id String The reference name for the stored liquidity token contract. amount UInt128 The amount of lp tokens to be sent { \"withdraw_liquidity\": { \"lp_token_id\": \"whale_ust\", \"amount\": \"100000\", }","title":"WithdrawLiquidity"},{"location":"Smart-Contracts/treasury/dapps/Astroport-Dapp/#swapasset","text":"ExecuteMsg used to compose a swap message for Terraswap which is then send to the Treasury for execution. Key Type Description offer_id String The reference name for the offered Asset's info. pool_id String The reference name for the stored pool contract. amount UInt128 The offer asset amount max_spread Option The maximum amount of spread considered acceptable. belief_price Option The current user-provided price for the token. When provided, max_spread is used to determine whether the trade is acceptable. { \"swap_asset\": { \"offer_id\": \"my_offer\", \"pool_id\": \"whale_ust\", \"amount\": \"100000\", \"max_spread\": null, \"slippage_tolerance\": null }","title":"SwapAsset"},{"location":"Smart-Contracts/treasury/dapps/Astroport-Dapp/#querymsg","text":"#[cfg_attr(not(feature = \"library\"), entry_point)] pub fn query(deps: Deps, _env: Env, msg: QueryMsg) -> StdResult<Binary> { match msg { QueryMsg::Base(message) => dapp_base_queries::handle_base_query(deps, message), } }","title":"QueryMsg"},{"location":"Smart-Contracts/treasury/dapps/Astroport-Dapp/#base_1","text":"See handle_base_query in Dapp Base","title":"Base"},{"location":"Smart-Contracts/treasury/dapps/Dapp-Base/","text":"Dapp Base Config BaseState The BaseState contains the main configurations such as addresses needed for sending messages and querying addresses #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] pub struct BaseState { pub treasury_address: Addr, pub trader: Addr, pub memory: Memory, } InstantiateMsg Dapps which are built out from the dapp_base or dapp_template should make use of the provided handle_base_init helper to instantiate the BaseState . This ensures a common structure for the configuration addresses. You may also choose to save your own state or config values as needed by defining a second but dapp-specific State . /// Handles creates the State and Memory object and returns them. pub fn handle_base_init(deps: Deps, msg: BaseInstantiateMsg) -> StdResult<BaseState> { // Memory let memory = Memory { address: deps.api.addr_validate(&msg.memory_addr)?, }; // Base state let state = BaseState { treasury_address: deps.api.addr_validate(&msg.treasury_address)?, trader: deps.api.addr_validate(&msg.trader)?, memory, }; Ok(state) } ExecuteMsg Dapps which are built out from the dapp_base or dapp_template should make use of the provided handle_base_message helper to handle some common config. This allows each implementation of a dapp to only have to focus on the unique use-cases that particular dapp needs to implement. Example of 'base' messages handled are Admin changes and changes to the BaseState object. handle_base_message pub fn handle_base_message( deps: DepsMut, info: MessageInfo, message: BaseExecuteMsg, ) -> BaseDAppResult { match message { BaseExecuteMsg::UpdateConfig { treasury_address, trader, memory, } => update_config(deps, info, treasury_address, trader, memory), BaseExecuteMsg::SetAdmin { admin } => set_admin(deps, info, admin), } } UpdateConfig Updates the configuration addresses used by the dapp. Key Type Description treasury_address * HumanAddr New address of the associated treasury contract trader * HumanAddr New address of trader memory * HumanAddr New address of the associated memory contract { \"update_config\": { \"treasury_address\": \"terra1...\", \"trader\": \"terra1...\", \"memory\": \"terra1...\" } } SetAdmin Change the established Admin for the Dapp. Can only be called by the currently established Admin of the contract. Key Type Description admin * HumanAddr New address of the admin { \"set_admin\": { \"admin\": \"terra1...\" } } QueryMsg Dapps which are built out from the dapp_base or dapp_template should make use of the provided handle_base_query helper to handle some common config. This means each dapp only needs to implement dapp-specific queries relevant to the use case for a given dapp. Example of 'base' messages handled are Admin changes and changes to the BaseState object. handle_base_query pub fn handle_base_query(deps: Deps, query: BaseQueryMsg) -> StdResult<Binary> { match query { BaseQueryMsg::Config {} => to_binary(&try_query_config(deps)?), } } Config Returns the BaseState which contains the main configuration addresses used by the dapp. { \"config\": { } } BaseStateresponse The main configuration addresses used by the dapp. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub struct BaseStateResponse { pub treasury_address: String, pub trader: String, pub memory_address: String, } { \"treasury_address\": \"terra1...\", \"trader\": \"terra1...\", \"memory_address\": \"terra1...\" }","title":"Dapp Base"},{"location":"Smart-Contracts/treasury/dapps/Dapp-Base/#dapp-base","text":"","title":"Dapp Base"},{"location":"Smart-Contracts/treasury/dapps/Dapp-Base/#config","text":"","title":"Config"},{"location":"Smart-Contracts/treasury/dapps/Dapp-Base/#basestate","text":"The BaseState contains the main configurations such as addresses needed for sending messages and querying addresses #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] pub struct BaseState { pub treasury_address: Addr, pub trader: Addr, pub memory: Memory, }","title":"BaseState"},{"location":"Smart-Contracts/treasury/dapps/Dapp-Base/#instantiatemsg","text":"Dapps which are built out from the dapp_base or dapp_template should make use of the provided handle_base_init helper to instantiate the BaseState . This ensures a common structure for the configuration addresses. You may also choose to save your own state or config values as needed by defining a second but dapp-specific State . /// Handles creates the State and Memory object and returns them. pub fn handle_base_init(deps: Deps, msg: BaseInstantiateMsg) -> StdResult<BaseState> { // Memory let memory = Memory { address: deps.api.addr_validate(&msg.memory_addr)?, }; // Base state let state = BaseState { treasury_address: deps.api.addr_validate(&msg.treasury_address)?, trader: deps.api.addr_validate(&msg.trader)?, memory, }; Ok(state) }","title":"InstantiateMsg"},{"location":"Smart-Contracts/treasury/dapps/Dapp-Base/#executemsg","text":"Dapps which are built out from the dapp_base or dapp_template should make use of the provided handle_base_message helper to handle some common config. This allows each implementation of a dapp to only have to focus on the unique use-cases that particular dapp needs to implement. Example of 'base' messages handled are Admin changes and changes to the BaseState object.","title":"ExecuteMsg"},{"location":"Smart-Contracts/treasury/dapps/Dapp-Base/#handle_base_message","text":"pub fn handle_base_message( deps: DepsMut, info: MessageInfo, message: BaseExecuteMsg, ) -> BaseDAppResult { match message { BaseExecuteMsg::UpdateConfig { treasury_address, trader, memory, } => update_config(deps, info, treasury_address, trader, memory), BaseExecuteMsg::SetAdmin { admin } => set_admin(deps, info, admin), } }","title":"handle_base_message"},{"location":"Smart-Contracts/treasury/dapps/Dapp-Base/#updateconfig","text":"Updates the configuration addresses used by the dapp. Key Type Description treasury_address * HumanAddr New address of the associated treasury contract trader * HumanAddr New address of trader memory * HumanAddr New address of the associated memory contract { \"update_config\": { \"treasury_address\": \"terra1...\", \"trader\": \"terra1...\", \"memory\": \"terra1...\" } }","title":"UpdateConfig"},{"location":"Smart-Contracts/treasury/dapps/Dapp-Base/#setadmin","text":"Change the established Admin for the Dapp. Can only be called by the currently established Admin of the contract. Key Type Description admin * HumanAddr New address of the admin { \"set_admin\": { \"admin\": \"terra1...\" } }","title":"SetAdmin"},{"location":"Smart-Contracts/treasury/dapps/Dapp-Base/#querymsg","text":"Dapps which are built out from the dapp_base or dapp_template should make use of the provided handle_base_query helper to handle some common config. This means each dapp only needs to implement dapp-specific queries relevant to the use case for a given dapp. Example of 'base' messages handled are Admin changes and changes to the BaseState object.","title":"QueryMsg"},{"location":"Smart-Contracts/treasury/dapps/Dapp-Base/#handle_base_query","text":"pub fn handle_base_query(deps: Deps, query: BaseQueryMsg) -> StdResult<Binary> { match query { BaseQueryMsg::Config {} => to_binary(&try_query_config(deps)?), } }","title":"handle_base_query"},{"location":"Smart-Contracts/treasury/dapps/Dapp-Base/#config_1","text":"Returns the BaseState which contains the main configuration addresses used by the dapp. { \"config\": { } }","title":"Config"},{"location":"Smart-Contracts/treasury/dapps/Dapp-Base/#basestateresponse","text":"The main configuration addresses used by the dapp. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub struct BaseStateResponse { pub treasury_address: String, pub trader: String, pub memory_address: String, } { \"treasury_address\": \"terra1...\", \"trader\": \"terra1...\", \"memory_address\": \"terra1...\" }","title":"BaseStateresponse"},{"location":"Smart-Contracts/treasury/dapps/Terraswap-Dapp/","text":"Terraswap Dapp Config BaseState See Dapp BaseState InstantiateMsg See Dapp BaseInstantiateMsg ExecuteMsg pub enum ExecuteMsg { /// dApp base messages that handle updating the config and addressbook Base(BaseExecuteMsg), /// Constructs a provide liquidity msg and forwards it to the treasury /// Calculates the required asset amount for the second asset in the pool. ProvideLiquidity { pool_id: String, main_asset_id: String, amount: Uint128, }, /// Constructs a provide liquidity msg and forwards it to the treasury. DetailedProvideLiquidity { assets: Vec<(String, Uint128)>, pool_id: String, slippage_tolerance: Option<Decimal>, }, /// Constructs a withdraw liquidity msg and forwards it to the treasury WithdrawLiquidity { lp_token_id: String, amount: Uint128, }, /// Constructs a swap msg and forwards it to the treasury SwapAsset { offer_id: String, pool_id: String, amount: Uint128, max_spread: Option<Decimal>, belief_price: Option<Decimal>, }, } Base See handle_base_message in Dapp Base ProvideLiquidity An abstraction around liquidity provision for Terraswap. Rather than specifying the contract addresses and asset structures, the caller provides a referential ID for the relevant contract addresses which have been stored in the contracts associated Memory contract. After the message is composed it is sent to the treasury for execution. The contract fetches what other asset is paired with the main_asset in the provided pool and adds that to the pool at the current ratio of the pool. Key Type Description pool_id String The reference name for the stored pool contract. Every trading pair ends with \"_pair\" main_asset_id String The reference name for the stored Asset to be used as the 'main' Asset amount UInt128 The amount of the specified main asset to be added to the pool { \"provide_liquidity\": { \"pool_id\": \"whale_ust_pair\", \"main_asset_id\": \"ust\", \"amount\": \"10000\" } DetailedProvideLiquidity Similar to ProvideLiquidity but with the ability to specify both asset amounts to be added and with what amount of slippage. Rather than specifying the contract addresses and asset structures, the caller provides a referential ID for the relevant contract addresses which have been stored in the contracts associated Memory contract. After the message is composed it is sent to the treasury for execution. Key Type Description pool_id String The reference name for the stored pool contract. assets Vec[String] Vector containing 2 asset reference names. slippage_tolerance Option[Decimal] The maximum amount of slippage considered acceptable. { \"detailed_provide_liquidity\": { \"pool_id\": \"whale_ust\", \"assets\": [\"stored_ust\", \"stored_krt\"], \"slippage_tolerance\": null } WithdrawLiquidity Composes a message to withdraw liquidity by returning an amount of the LP token received on liquidity provision. The message is then sent to the treasury for execution. Key Type Description lp_token_id String The reference name for the stored liquidity token contract. amount UInt128 The amount of lp tokens to be sent { \"withdraw_liquidity\": { \"lp_token_id\": \"whale_ust\", \"amount\": \"100000\", } SwapAsset ExecuteMsg used to compose a swap message for Terraswap which is then send to the Treasury for execution. Key Type Description offer_id String The reference name for the offered Asset's info. pool_id String The reference name for the stored pool contract. amount UInt128 The offer asset amount max_spread Option The maximum amount of spread considered acceptable. belief_price Option The current user-provided price for the token. When provided, max_spread is used to determine whether the trade is acceptable. { \"swap_asset\": { \"offer_id\": \"my_offer\", \"pool_id\": \"whale_ust\", \"amount\": \"100000\", \"max_spread\": null, \"slippage_tolerance\": null } QueryMsg pub enum QueryMsg { /// Handles all the base query msgs Base(BaseQueryMsg), } Base See handle_base_query in Dapp Base","title":"Terraswap Dapp"},{"location":"Smart-Contracts/treasury/dapps/Terraswap-Dapp/#terraswap-dapp","text":"","title":"Terraswap Dapp"},{"location":"Smart-Contracts/treasury/dapps/Terraswap-Dapp/#config","text":"","title":"Config"},{"location":"Smart-Contracts/treasury/dapps/Terraswap-Dapp/#basestate","text":"See Dapp BaseState","title":"BaseState"},{"location":"Smart-Contracts/treasury/dapps/Terraswap-Dapp/#instantiatemsg","text":"See Dapp BaseInstantiateMsg","title":"InstantiateMsg"},{"location":"Smart-Contracts/treasury/dapps/Terraswap-Dapp/#executemsg","text":"pub enum ExecuteMsg { /// dApp base messages that handle updating the config and addressbook Base(BaseExecuteMsg), /// Constructs a provide liquidity msg and forwards it to the treasury /// Calculates the required asset amount for the second asset in the pool. ProvideLiquidity { pool_id: String, main_asset_id: String, amount: Uint128, }, /// Constructs a provide liquidity msg and forwards it to the treasury. DetailedProvideLiquidity { assets: Vec<(String, Uint128)>, pool_id: String, slippage_tolerance: Option<Decimal>, }, /// Constructs a withdraw liquidity msg and forwards it to the treasury WithdrawLiquidity { lp_token_id: String, amount: Uint128, }, /// Constructs a swap msg and forwards it to the treasury SwapAsset { offer_id: String, pool_id: String, amount: Uint128, max_spread: Option<Decimal>, belief_price: Option<Decimal>, }, }","title":"ExecuteMsg"},{"location":"Smart-Contracts/treasury/dapps/Terraswap-Dapp/#base","text":"See handle_base_message in Dapp Base","title":"Base"},{"location":"Smart-Contracts/treasury/dapps/Terraswap-Dapp/#provideliquidity","text":"An abstraction around liquidity provision for Terraswap. Rather than specifying the contract addresses and asset structures, the caller provides a referential ID for the relevant contract addresses which have been stored in the contracts associated Memory contract. After the message is composed it is sent to the treasury for execution. The contract fetches what other asset is paired with the main_asset in the provided pool and adds that to the pool at the current ratio of the pool. Key Type Description pool_id String The reference name for the stored pool contract. Every trading pair ends with \"_pair\" main_asset_id String The reference name for the stored Asset to be used as the 'main' Asset amount UInt128 The amount of the specified main asset to be added to the pool { \"provide_liquidity\": { \"pool_id\": \"whale_ust_pair\", \"main_asset_id\": \"ust\", \"amount\": \"10000\" }","title":"ProvideLiquidity"},{"location":"Smart-Contracts/treasury/dapps/Terraswap-Dapp/#detailedprovideliquidity","text":"Similar to ProvideLiquidity but with the ability to specify both asset amounts to be added and with what amount of slippage. Rather than specifying the contract addresses and asset structures, the caller provides a referential ID for the relevant contract addresses which have been stored in the contracts associated Memory contract. After the message is composed it is sent to the treasury for execution. Key Type Description pool_id String The reference name for the stored pool contract. assets Vec[String] Vector containing 2 asset reference names. slippage_tolerance Option[Decimal] The maximum amount of slippage considered acceptable. { \"detailed_provide_liquidity\": { \"pool_id\": \"whale_ust\", \"assets\": [\"stored_ust\", \"stored_krt\"], \"slippage_tolerance\": null }","title":"DetailedProvideLiquidity"},{"location":"Smart-Contracts/treasury/dapps/Terraswap-Dapp/#withdrawliquidity","text":"Composes a message to withdraw liquidity by returning an amount of the LP token received on liquidity provision. The message is then sent to the treasury for execution. Key Type Description lp_token_id String The reference name for the stored liquidity token contract. amount UInt128 The amount of lp tokens to be sent { \"withdraw_liquidity\": { \"lp_token_id\": \"whale_ust\", \"amount\": \"100000\", }","title":"WithdrawLiquidity"},{"location":"Smart-Contracts/treasury/dapps/Terraswap-Dapp/#swapasset","text":"ExecuteMsg used to compose a swap message for Terraswap which is then send to the Treasury for execution. Key Type Description offer_id String The reference name for the offered Asset's info. pool_id String The reference name for the stored pool contract. amount UInt128 The offer asset amount max_spread Option The maximum amount of spread considered acceptable. belief_price Option The current user-provided price for the token. When provided, max_spread is used to determine whether the trade is acceptable. { \"swap_asset\": { \"offer_id\": \"my_offer\", \"pool_id\": \"whale_ust\", \"amount\": \"100000\", \"max_spread\": null, \"slippage_tolerance\": null }","title":"SwapAsset"},{"location":"Smart-Contracts/treasury/dapps/Terraswap-Dapp/#querymsg","text":"pub enum QueryMsg { /// Handles all the base query msgs Base(BaseQueryMsg), }","title":"QueryMsg"},{"location":"Smart-Contracts/treasury/dapps/Terraswap-Dapp/#base_1","text":"See handle_base_query in Dapp Base","title":"Base"},{"location":"Smart-Contracts/treasury/dapps/Vault-Dapp/","text":"Vault Dapp Config This dapps config is composed of two state objects. A BaseState which every dapp have and an optionally used State for any Dapp-specific config values BaseState See Dapp Base State Name Type Description liquidity_token Addr The contract address of the UST-Vault's LP token InstantiateMsg #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] pub struct InstantiateMsg { pub base: BaseInstantiateMsg, pub token_code_id: u64, pub fee: Decimal, pub deposit_asset: String, pub vault_lp_token_name: Option<String>, pub vault_lp_token_symbol: Option<String>, } ExecuteMsg Available Execution operations on the Vault-Dapp: #[cfg_attr(not(feature = \"library\"), entry_point)] pub enum ExecuteMsg { Base(BaseExecuteMsg), // Add dapp-specific messages here Receive(Cw20ReceiveMsg), ProvideLiquidity { asset: Asset, }, UpdatePool { deposit_asset: Option<String>, assets_to_add: Vec<String>, assets_to_remove: Vec<String>, }, SetFee { fee: Fee, }, } Base See handle_base_message in Dapp Base Receive Can be called during a CW20 token transfer when tokens are deposited into the Stablecoin Vault. Allows the token transfer to execute a Receive Hook as a subsequent action within the same transaction. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum Receive { Cw20ReceiveMsg { amount: Uint128, sender: HumanAddr, msg: Option<Binary>, } } Key Type Description amount Uint128 Amount of tokens received sender HumanAddr Sender of token transfer msg * Binary Base64-encoded JSON of Receive Hook * = optional ProvideLiquidity An abstraction around liquidity provision allowing a vault to have liquidity provided to it either with a Native token or with a CW20. Key Type Description asset Asset Asset to be provided as liquidity. Includes asset info and amount. { \"provide_liquidity\": { \"asset\": { \"info\": { \"native_token\": { \"denom\": \"uusd\" }, }, \"amount\": \"1000000\", }, } UpdatePool Update the vault's associated pool information and asset information. Key Type Description deposit_asset * Option New deposit asset to be used for the pool. assets_to_add * Vec Assets to be included as claimable assets_to_remove * Vec Assets to be removed from being claimable Note: The 'assets' defined in this call use reference names which are stored in the memory contract rather than full asset information or contract addresses. See the Memory Contract for more { \"update_pool\": { \"deposit_asset\": \"ust\", \"assets_to_add\": [\"ust\", \"krw\", \"anotherone\"], \"assets_to_remove\": [\"bluna\"] } } SetFee Update the configured fee information for the vault-dapp. Key Type Description fee * Fee New fee information to set. { \"set_fee\": { \"fee\": { \"share\": 1.01 } } } Receive Hooks Payable functions when you send a payment to the contract with an appropriate message. WithdrawLiquidity Attempt to withdraw deposits. Fees are calculated and deducted. LP tokens submitted with a withdrawal request are burned. The Treasury withdraw fee is paid out by transfering ownership of a fraction of the LP tokens to the treasury contract. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum Cw20HookMsg { WithdrawLiquidity {}, } QueryMsg pub enum QueryMsg { Base(BaseQueryMsg), // Add dapp-specific queries here State {}, } Base See handle_base_query in Dapp Base State Returns the saved dapp-specific configuration values saved in State. { \"state\": {} } Name Type Description StateResponse Saved dapp-specific configuration values. { \"liquidity_token\": \"terra1...\" } Name Type Description liquidity_token String The contract address of the Vault's LP token","title":"Vault Dapp"},{"location":"Smart-Contracts/treasury/dapps/Vault-Dapp/#vault-dapp","text":"","title":"Vault Dapp"},{"location":"Smart-Contracts/treasury/dapps/Vault-Dapp/#config","text":"This dapps config is composed of two state objects. A BaseState which every dapp have and an optionally used State for any Dapp-specific config values","title":"Config"},{"location":"Smart-Contracts/treasury/dapps/Vault-Dapp/#basestate","text":"See Dapp Base","title":"BaseState"},{"location":"Smart-Contracts/treasury/dapps/Vault-Dapp/#state","text":"Name Type Description liquidity_token Addr The contract address of the UST-Vault's LP token","title":"State"},{"location":"Smart-Contracts/treasury/dapps/Vault-Dapp/#instantiatemsg","text":"#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] pub struct InstantiateMsg { pub base: BaseInstantiateMsg, pub token_code_id: u64, pub fee: Decimal, pub deposit_asset: String, pub vault_lp_token_name: Option<String>, pub vault_lp_token_symbol: Option<String>, }","title":"InstantiateMsg"},{"location":"Smart-Contracts/treasury/dapps/Vault-Dapp/#executemsg","text":"Available Execution operations on the Vault-Dapp: #[cfg_attr(not(feature = \"library\"), entry_point)] pub enum ExecuteMsg { Base(BaseExecuteMsg), // Add dapp-specific messages here Receive(Cw20ReceiveMsg), ProvideLiquidity { asset: Asset, }, UpdatePool { deposit_asset: Option<String>, assets_to_add: Vec<String>, assets_to_remove: Vec<String>, }, SetFee { fee: Fee, }, }","title":"ExecuteMsg"},{"location":"Smart-Contracts/treasury/dapps/Vault-Dapp/#base","text":"See handle_base_message in Dapp Base","title":"Base"},{"location":"Smart-Contracts/treasury/dapps/Vault-Dapp/#receive","text":"Can be called during a CW20 token transfer when tokens are deposited into the Stablecoin Vault. Allows the token transfer to execute a Receive Hook as a subsequent action within the same transaction. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum Receive { Cw20ReceiveMsg { amount: Uint128, sender: HumanAddr, msg: Option<Binary>, } } Key Type Description amount Uint128 Amount of tokens received sender HumanAddr Sender of token transfer msg * Binary Base64-encoded JSON of Receive Hook * = optional","title":"Receive"},{"location":"Smart-Contracts/treasury/dapps/Vault-Dapp/#provideliquidity","text":"An abstraction around liquidity provision allowing a vault to have liquidity provided to it either with a Native token or with a CW20. Key Type Description asset Asset Asset to be provided as liquidity. Includes asset info and amount. { \"provide_liquidity\": { \"asset\": { \"info\": { \"native_token\": { \"denom\": \"uusd\" }, }, \"amount\": \"1000000\", }, }","title":"ProvideLiquidity"},{"location":"Smart-Contracts/treasury/dapps/Vault-Dapp/#updatepool","text":"Update the vault's associated pool information and asset information. Key Type Description deposit_asset * Option New deposit asset to be used for the pool. assets_to_add * Vec Assets to be included as claimable assets_to_remove * Vec Assets to be removed from being claimable Note: The 'assets' defined in this call use reference names which are stored in the memory contract rather than full asset information or contract addresses. See the Memory Contract for more { \"update_pool\": { \"deposit_asset\": \"ust\", \"assets_to_add\": [\"ust\", \"krw\", \"anotherone\"], \"assets_to_remove\": [\"bluna\"] } }","title":"UpdatePool"},{"location":"Smart-Contracts/treasury/dapps/Vault-Dapp/#setfee","text":"Update the configured fee information for the vault-dapp. Key Type Description fee * Fee New fee information to set. { \"set_fee\": { \"fee\": { \"share\": 1.01 } } }","title":"SetFee"},{"location":"Smart-Contracts/treasury/dapps/Vault-Dapp/#receive-hooks","text":"Payable functions when you send a payment to the contract with an appropriate message.","title":"Receive Hooks"},{"location":"Smart-Contracts/treasury/dapps/Vault-Dapp/#withdrawliquidity","text":"Attempt to withdraw deposits. Fees are calculated and deducted. LP tokens submitted with a withdrawal request are burned. The Treasury withdraw fee is paid out by transfering ownership of a fraction of the LP tokens to the treasury contract. #[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)] #[serde(rename_all = \"snake_case\")] pub enum Cw20HookMsg { WithdrawLiquidity {}, }","title":"WithdrawLiquidity"},{"location":"Smart-Contracts/treasury/dapps/Vault-Dapp/#querymsg","text":"pub enum QueryMsg { Base(BaseQueryMsg), // Add dapp-specific queries here State {}, }","title":"QueryMsg"},{"location":"Smart-Contracts/treasury/dapps/Vault-Dapp/#base_1","text":"See handle_base_query in Dapp Base","title":"Base"},{"location":"Smart-Contracts/treasury/dapps/Vault-Dapp/#state_1","text":"Returns the saved dapp-specific configuration values saved in State. { \"state\": {} } Name Type Description","title":"State"},{"location":"Smart-Contracts/treasury/dapps/Vault-Dapp/#stateresponse","text":"Saved dapp-specific configuration values. { \"liquidity_token\": \"terra1...\" } Name Type Description liquidity_token String The contract address of the Vault's LP token","title":"StateResponse"},{"location":"protocol/Arch/","text":"White Whale Architecture The White Whale protocol is composed of a number of different services implemented as smart contracts. The following architectural diagram describes the groups of services and how they interact with one another.","title":"White Whale Architecture"},{"location":"protocol/Arch/#white-whale-architecture","text":"The White Whale protocol is composed of a number of different services implemented as smart contracts. The following architectural diagram describes the groups of services and how they interact with one another.","title":"White Whale Architecture"},{"location":"protocol/Arb-Vaults/Arbitrage_Vaults/","text":"Arbitrage Exposure The Arbitrage Vaults are the main product of White Whale. Arbitrage is the simultaneous purchase and sale of the same asset in different markets in order to profit from differences in the asset's listed price. Arbitrage exists as a result of market inefficiencies and it both exploits those inefficiencies and resolves them. White Whale currently takes advantage of arbitrage opportunities on Terra, specifically UST peg arbitrage, with plans to add more strategies and more chains. UST Vault Our flagship product is the UST Vault. The vault deposits the UST into Anchor protocol to generate a base yield. The vault then performs arbitrage for additional risk free yield on top of the Anchor yield. The UST vault's main purpose is to protect the UST peg through L1 seigniorage arbitrage, but also earns revenue from Multi-Dex Arbitrage and Flash Loans. L1 Seigniorage Arbitrage: Note: Validators must exchange 1 UST for a $1 worth of LUNA. When 1 UST < $1, exchange 1 UST for $1 worth of LUNA with validators sell LUNA on DEX. When 1 UST > $1, buy LUNA with UST on DEX, then exchange $1 worth of LUNA for 1 UST with validators. Multi-Dex Arbitrage: Luna is trading at $99 dollars on Terraswap. Luna is trading at $100 dollars on Astroport. Buy Luna on Terraswap sell on Astroport. Flash-Loans: White Whale offers the possibility to leverage the funds held inside the vault through flash loans. A small fee of .1% will be charged on the borrowed funds. The smart contract logic ensures all funds are returned in the same transaction. A detailed description is provided in this Medium article. Yield Total Vault Yield = Anchor Yield + Arbitrage Profits (L1 + Multi-Dex Arbitrage) + Flashloan Income APR Calculation We take average of vault tvl and profits for last 7 days and: 1. weeklyAPR = (100 * weeklyProfit ) / tvlAverageLast7Days 2. APR = (365 * weeklyAPR ) / 7 Vault Fees Deposit - Anchor's Deposit Fee into Earn Withdrawal - 0.1% Arb Profit - 20% of any Arbitrage trade profit goes to Treasury Note: Treasury does NOT take any percentage of the Anchor Earn Yield. Other Vaults Other asset vaults, such as the LUNA ARB vault, will be added by the team as the development phase continues. Ultimately, the community will decide which new asset vaults to add through governance proposals.","title":"Arbitrage Exposure"},{"location":"protocol/Arb-Vaults/Arbitrage_Vaults/#arbitrage-exposure","text":"The Arbitrage Vaults are the main product of White Whale. Arbitrage is the simultaneous purchase and sale of the same asset in different markets in order to profit from differences in the asset's listed price. Arbitrage exists as a result of market inefficiencies and it both exploits those inefficiencies and resolves them. White Whale currently takes advantage of arbitrage opportunities on Terra, specifically UST peg arbitrage, with plans to add more strategies and more chains.","title":"Arbitrage Exposure"},{"location":"protocol/Arb-Vaults/Arbitrage_Vaults/#ust-vault","text":"Our flagship product is the UST Vault. The vault deposits the UST into Anchor protocol to generate a base yield. The vault then performs arbitrage for additional risk free yield on top of the Anchor yield. The UST vault's main purpose is to protect the UST peg through L1 seigniorage arbitrage, but also earns revenue from Multi-Dex Arbitrage and Flash Loans. L1 Seigniorage Arbitrage: Note: Validators must exchange 1 UST for a $1 worth of LUNA. When 1 UST < $1, exchange 1 UST for $1 worth of LUNA with validators sell LUNA on DEX. When 1 UST > $1, buy LUNA with UST on DEX, then exchange $1 worth of LUNA for 1 UST with validators. Multi-Dex Arbitrage: Luna is trading at $99 dollars on Terraswap. Luna is trading at $100 dollars on Astroport. Buy Luna on Terraswap sell on Astroport. Flash-Loans: White Whale offers the possibility to leverage the funds held inside the vault through flash loans. A small fee of .1% will be charged on the borrowed funds. The smart contract logic ensures all funds are returned in the same transaction. A detailed description is provided in this Medium article.","title":"UST Vault"},{"location":"protocol/Arb-Vaults/Arbitrage_Vaults/#yield","text":"Total Vault Yield = Anchor Yield + Arbitrage Profits (L1 + Multi-Dex Arbitrage) + Flashloan Income","title":"Yield"},{"location":"protocol/Arb-Vaults/Arbitrage_Vaults/#apr-calculation","text":"We take average of vault tvl and profits for last 7 days and: 1. weeklyAPR = (100 * weeklyProfit ) / tvlAverageLast7Days 2. APR = (365 * weeklyAPR ) / 7","title":"APR Calculation"},{"location":"protocol/Arb-Vaults/Arbitrage_Vaults/#vault-fees","text":"Deposit - Anchor's Deposit Fee into Earn Withdrawal - 0.1% Arb Profit - 20% of any Arbitrage trade profit goes to Treasury Note: Treasury does NOT take any percentage of the Anchor Earn Yield.","title":"Vault Fees"},{"location":"protocol/Arb-Vaults/Arbitrage_Vaults/#other-vaults","text":"Other asset vaults, such as the LUNA ARB vault, will be added by the team as the development phase continues. Ultimately, the community will decide which new asset vaults to add through governance proposals.","title":"Other Vaults"},{"location":"protocol/Flash-Loans/Flash_Loans/","text":"Flash Loans White Whale's development team worked to augment our original UST Vault concept to enable users on the network to avail of the first flash loans on Terra and possibly the first non-EVM implementation of flash loans. The net effect of this is now funds which are provided by the community to keep the peg can also be utilized by the community as a composable DeFi \"money lego\" in the form of an uncollateralised loan product. Flash Loans Explained Flash Loans are special transactions that allow the borrowing of an asset, as long as the borrowed amount (and a fee) is returned before the end of the transaction (also called One Block Borrows). These transactions do not require a user to supply collateral prior to engaging in the transaction. There is no real world analogy to Flash Loans, so it requires some basic understanding of how state is managed within blocks in blockchains. Source - Aave Flash Loans provide an innovative way for users of the Terra network to take out uncollateralised loans with the caveat that the loan is taken out and paid back within the same transaction. At a high level, flash loans follow this flow : Call Flash Loan on UST Vault UST provided from the Vault to caller Caller uses flash loan collateral for a series of actions Caller calls repay functionality of the flash loan Steps 1-4 all happen in 1 transaction. The last step has some checks in place to ensure that overall the loan can be paid back in full with any fees but also that there is some degree of profit. If for example the repay functionality is not called or it is called with not enough funds, the entire flash loan with fail/revert and will have never been taken out. Instead only gas is spent. Applications of Flash Loans White Whale Flash Loans are already used in part by the White Whale Protocol liquidity on large arbs. Other examples in the wild include: Arbitrage between assets, without needing to have the principal amount to execute the arbitrage. Liquidating borrow positions, without having to repay the debt of the positions and using discounted collateral claimed to payoff flashLoan amount + fee. Arbitrage minting or burning of Nebula Protocol Clusters to aid in the re-balancing of a given cluster capturing any delta as profit. How to use Flash Loans Below provides a guideline on how you can make use of Flash Loans. The typical use case would be to take the below concepts and implement them in your own smart contract or series of scripts. We try to make this a little easier for you with our Flash Loan Tools repo and contribution by community members is encouraged. After all White Whale is nothing without its community. Calling the FlashLoan on a Vault In order to take a Flash Loan. A prospective caller must send a FlashLoan variant of ExecuteMsg to the UST Vault. See Flash Loan schema for an example JSON you can use as well as detailed info about each of the fields required in the request. Any request to a flash loan enabled vault requires that the requested asset be the same as the base asset of the Vault. It is not possible to borrow EUT from the UST Vault. FlashLoanPayload The FlashLoanPayload is the structure through which a user requests a flash loan. It has two fields a requested_asset which is of type Asset and a callback field which is a Binary. The callback Binary is where you as the loan caller can place your actions to be performed with the loaned funds. There is no restriction here whatsoever on what can be done apart from that it must be achievable within a block with some degree of profit. The callback Binary is passed straight to the composition of a new CosmosMsg which will be encapsulated within the Vaults profitability logic: // Construct return call with received binary let return_call = CosmosMsg::Wasm(WasmMsg::Execute { contract_addr: info.sender.into(), msg: payload.callback, funds: vec![], }); A key point to take in here is that we do no checking on what your callback series of messages should do after getting funding, that is up to you. This includes ensuring your logic works as intended but if you compose a flash loan which loses money you have some assurance in the contract's in-built profit checking logic. Completing the Flash Loan On other chains depending on the type of flash loan an actual repayment message needs to be supplied. This makes the composability of flash loans a little harder as you are making this big sandwich of messages yourself with binaries and addresses. The White Whale Flash Loan approach is a little different in that we only have 1 type of Flash Loan and we handle all the repayment logic for you. This means you the user can focus on your use case for the loaned funds rather than losing hours and possible opportunities trying to figure out how to repay the thing. Helpful resources In addition to this doc, the White Whale team have provided an example repo, containing a starter smart contract which uses the flash loan capability of the Vault. This starter contract provides a quick getting-started point if you just want to focus on your use case and what should happen in between the loan and payback to generate a profit. Flash Loan Tools In future we will update this repository with more of our internal and partner created flash loan use cases either in the form of just a contract or providing both a contract and a bot to call it. Going deeper on flash loans All of the above is nice and all but its still remains rather high level. To truly understand how the flash loan functionality we have developed works lets take a closer look at the code of the v1 release. Starting with the flash loan call itself. Assuming we have provided a valid FlashLoanPayload the handle_flashloan execute message handler will first ensure the request asset is valid for the vault. // Check if requested asset is base token of vault deposit_info.assert(&payload.requested_asset.info)?; This ensures only UST can be requested from the UST Vault and Luna from the Luna Vault. A whitelisting system is in place to restrict who can take a flash loan to only whitelisted addresses or all addresses. As of Governance Proposal No. 4 this system was disabled and Flash Loans were officially opened too all on Terra. Provided there is enough funds in the vault for the requested loan and a simple tax buffer the loan can proceed. Otherwise a Broke exception is returned: if total_value < requested_asset.amount + tax_buffer { return Err(StableVaultError::Broke {}); } Another check is performed to ensure the Vault has enough liquid assets to service this loan, if not a withdrawal from anchor is prepared: // Withdraw funds from Anchor if needed // FEE_BUFFER as buffer for fees and taxes if (requested_asset.amount + tax_buffer) > stables_available { // Attempt to remove some money from anchor let to_withdraw = (requested_asset.amount + tax_buffer) - stables_available; let aust_exchange_rate = query_aust_exchange_rate( env.clone(), deps.as_ref(), state.anchor_money_market_address.to_string(), )?; let withdraw_msg = anchor_withdraw_msg( state.aust_address, state.anchor_money_market_address, to_withdraw * aust_exchange_rate.inv().unwrap(), )?; // Add msg to response and update withdrawn value response = response .add_message(withdraw_msg) .add_attribute(\"Anchor withdrawal\", to_withdraw.to_string()) .add_attribute(\"ust_aust_rate\", aust_exchange_rate.to_string()); } Assuming all is well with the above checks and balances, we now have funds ready to service a loan. The desired action messages to perform are passed to the encapsulate_payload function which wraps up all the messages as submessages also adding the AfterTrade CallbackMsg to the end as a message. This CallBackMsg is what handles the final repayment of the flash loan and also calculates the final profit of the loan. Note: When calculating the final profit and performance of the loan. If a loss is detected, which can be described as any non-complete repayment of both the loan and the loan fee then the entire transaction will be reverted as a losing trade Conclusion The above is a whole lot to digest but it is provided in the hopes Flash Loans can be somewhat demystified in DeFi and as we continue to advance in the space they may become a tool everyone can use.","title":"Flash Loans"},{"location":"protocol/Flash-Loans/Flash_Loans/#flash-loans","text":"White Whale's development team worked to augment our original UST Vault concept to enable users on the network to avail of the first flash loans on Terra and possibly the first non-EVM implementation of flash loans. The net effect of this is now funds which are provided by the community to keep the peg can also be utilized by the community as a composable DeFi \"money lego\" in the form of an uncollateralised loan product.","title":"Flash Loans"},{"location":"protocol/Flash-Loans/Flash_Loans/#flash-loans-explained","text":"Flash Loans are special transactions that allow the borrowing of an asset, as long as the borrowed amount (and a fee) is returned before the end of the transaction (also called One Block Borrows). These transactions do not require a user to supply collateral prior to engaging in the transaction. There is no real world analogy to Flash Loans, so it requires some basic understanding of how state is managed within blocks in blockchains. Source - Aave Flash Loans provide an innovative way for users of the Terra network to take out uncollateralised loans with the caveat that the loan is taken out and paid back within the same transaction. At a high level, flash loans follow this flow : Call Flash Loan on UST Vault UST provided from the Vault to caller Caller uses flash loan collateral for a series of actions Caller calls repay functionality of the flash loan Steps 1-4 all happen in 1 transaction. The last step has some checks in place to ensure that overall the loan can be paid back in full with any fees but also that there is some degree of profit. If for example the repay functionality is not called or it is called with not enough funds, the entire flash loan with fail/revert and will have never been taken out. Instead only gas is spent.","title":"Flash Loans Explained"},{"location":"protocol/Flash-Loans/Flash_Loans/#applications-of-flash-loans","text":"White Whale Flash Loans are already used in part by the White Whale Protocol liquidity on large arbs. Other examples in the wild include: Arbitrage between assets, without needing to have the principal amount to execute the arbitrage. Liquidating borrow positions, without having to repay the debt of the positions and using discounted collateral claimed to payoff flashLoan amount + fee. Arbitrage minting or burning of Nebula Protocol Clusters to aid in the re-balancing of a given cluster capturing any delta as profit.","title":"Applications of Flash Loans"},{"location":"protocol/Flash-Loans/Flash_Loans/#how-to-use-flash-loans","text":"Below provides a guideline on how you can make use of Flash Loans. The typical use case would be to take the below concepts and implement them in your own smart contract or series of scripts. We try to make this a little easier for you with our Flash Loan Tools repo and contribution by community members is encouraged. After all White Whale is nothing without its community.","title":"How to use Flash Loans"},{"location":"protocol/Flash-Loans/Flash_Loans/#calling-the-flashloan-on-a-vault","text":"In order to take a Flash Loan. A prospective caller must send a FlashLoan variant of ExecuteMsg to the UST Vault. See Flash Loan schema for an example JSON you can use as well as detailed info about each of the fields required in the request. Any request to a flash loan enabled vault requires that the requested asset be the same as the base asset of the Vault. It is not possible to borrow EUT from the UST Vault.","title":"Calling the FlashLoan on a Vault"},{"location":"protocol/Flash-Loans/Flash_Loans/#flashloanpayload","text":"The FlashLoanPayload is the structure through which a user requests a flash loan. It has two fields a requested_asset which is of type Asset and a callback field which is a Binary. The callback Binary is where you as the loan caller can place your actions to be performed with the loaned funds. There is no restriction here whatsoever on what can be done apart from that it must be achievable within a block with some degree of profit. The callback Binary is passed straight to the composition of a new CosmosMsg which will be encapsulated within the Vaults profitability logic: // Construct return call with received binary let return_call = CosmosMsg::Wasm(WasmMsg::Execute { contract_addr: info.sender.into(), msg: payload.callback, funds: vec![], }); A key point to take in here is that we do no checking on what your callback series of messages should do after getting funding, that is up to you. This includes ensuring your logic works as intended but if you compose a flash loan which loses money you have some assurance in the contract's in-built profit checking logic.","title":"FlashLoanPayload"},{"location":"protocol/Flash-Loans/Flash_Loans/#completing-the-flash-loan","text":"On other chains depending on the type of flash loan an actual repayment message needs to be supplied. This makes the composability of flash loans a little harder as you are making this big sandwich of messages yourself with binaries and addresses. The White Whale Flash Loan approach is a little different in that we only have 1 type of Flash Loan and we handle all the repayment logic for you. This means you the user can focus on your use case for the loaned funds rather than losing hours and possible opportunities trying to figure out how to repay the thing.","title":"Completing the Flash Loan"},{"location":"protocol/Flash-Loans/Flash_Loans/#helpful-resources","text":"In addition to this doc, the White Whale team have provided an example repo, containing a starter smart contract which uses the flash loan capability of the Vault. This starter contract provides a quick getting-started point if you just want to focus on your use case and what should happen in between the loan and payback to generate a profit. Flash Loan Tools In future we will update this repository with more of our internal and partner created flash loan use cases either in the form of just a contract or providing both a contract and a bot to call it.","title":"Helpful resources"},{"location":"protocol/Flash-Loans/Flash_Loans/#going-deeper-on-flash-loans","text":"All of the above is nice and all but its still remains rather high level. To truly understand how the flash loan functionality we have developed works lets take a closer look at the code of the v1 release. Starting with the flash loan call itself. Assuming we have provided a valid FlashLoanPayload the handle_flashloan execute message handler will first ensure the request asset is valid for the vault. // Check if requested asset is base token of vault deposit_info.assert(&payload.requested_asset.info)?; This ensures only UST can be requested from the UST Vault and Luna from the Luna Vault. A whitelisting system is in place to restrict who can take a flash loan to only whitelisted addresses or all addresses. As of Governance Proposal No. 4 this system was disabled and Flash Loans were officially opened too all on Terra. Provided there is enough funds in the vault for the requested loan and a simple tax buffer the loan can proceed. Otherwise a Broke exception is returned: if total_value < requested_asset.amount + tax_buffer { return Err(StableVaultError::Broke {}); } Another check is performed to ensure the Vault has enough liquid assets to service this loan, if not a withdrawal from anchor is prepared: // Withdraw funds from Anchor if needed // FEE_BUFFER as buffer for fees and taxes if (requested_asset.amount + tax_buffer) > stables_available { // Attempt to remove some money from anchor let to_withdraw = (requested_asset.amount + tax_buffer) - stables_available; let aust_exchange_rate = query_aust_exchange_rate( env.clone(), deps.as_ref(), state.anchor_money_market_address.to_string(), )?; let withdraw_msg = anchor_withdraw_msg( state.aust_address, state.anchor_money_market_address, to_withdraw * aust_exchange_rate.inv().unwrap(), )?; // Add msg to response and update withdrawn value response = response .add_message(withdraw_msg) .add_attribute(\"Anchor withdrawal\", to_withdraw.to_string()) .add_attribute(\"ust_aust_rate\", aust_exchange_rate.to_string()); } Assuming all is well with the above checks and balances, we now have funds ready to service a loan. The desired action messages to perform are passed to the encapsulate_payload function which wraps up all the messages as submessages also adding the AfterTrade CallbackMsg to the end as a message. This CallBackMsg is what handles the final repayment of the flash loan and also calculates the final profit of the loan. Note: When calculating the final profit and performance of the loan. If a loss is detected, which can be described as any non-complete repayment of both the loan and the loan fee then the entire transaction will be reverted as a losing trade","title":"Going deeper on flash loans"},{"location":"protocol/Flash-Loans/Flash_Loans/#conclusion","text":"The above is a whole lot to digest but it is provided in the hopes Flash Loans can be somewhat demystified in DeFi and as we continue to advance in the space they may become a tool everyone can use.","title":"Conclusion"},{"location":"protocol/Flash-Loans/Flash_Loans_CookBook/","text":"Cookbook Starting as a barren space, this goal of this piece of documentation is to try and cluster as much info as possible for certain DeFi use cases so that others that stumble upon it can simply take a recipe listed below and achieve their own delicious DeFi use case. Community contribution encouraged.","title":"Cookbook"},{"location":"protocol/Flash-Loans/Flash_Loans_CookBook/#cookbook","text":"Starting as a barren space, this goal of this piece of documentation is to try and cluster as much info as possible for certain DeFi use cases so that others that stumble upon it can simply take a recipe listed below and achieve their own delicious DeFi use case. Community contribution encouraged.","title":"Cookbook"},{"location":"protocol/governance/Governance-Overview/","text":"White Whale Governance The development and maintenance of the White Whale Protocol is driven by the White Whale community through democratic governance. In the near future White Whale governance will be the sole authority allowed to apply protocol changes or upgrades.","title":"White Whale Governance"},{"location":"protocol/governance/Governance-Overview/#white-whale-governance","text":"The development and maintenance of the White Whale Protocol is driven by the White Whale community through democratic governance. In the near future White Whale governance will be the sole authority allowed to apply protocol changes or upgrades.","title":"White Whale Governance"},{"location":"protocol/whale-token/Whale_token/","text":"Whale Token The White Whale (Symbol: $WHALE) is the CW20 token used throughout the protocol. Whale token initially allows community members to stake within governance and have their say on key proposed actions that are presented to the community.","title":"Whale Token"},{"location":"protocol/whale-token/Whale_token/#whale-token","text":"The White Whale (Symbol: $WHALE) is the CW20 token used throughout the protocol. Whale token initially allows community members to stake within governance and have their say on key proposed actions that are presented to the community.","title":"Whale Token"},{"location":"user-guide/Liquidity/","text":"Liquidity Providing Liquidity can be provided for WHALE Tokens https://app.whitewhale.money/swap . The WHALE tokens can be used for governance staking and voting. See STAKING section for details. Note that the liquidity providing rewards are only from transaction fees. There are no token reward incentives for providing WHALE-UST liquidity. Tutorial assumes you have: A Terra Wallet. If not, see the WebApp section. WHALE tokens. If not, see the Swap section. Providing WHALE-UST Liquidity 1. Connect Wallet 2. Navigate to the [SWAP] page 3. Select [POOL] 4. Enter equal amounts of WHALE and UST that you would like to provide as liquidity. Then select [PROVIDE] 5. Select [POST] to confirm the transaction Withdrawing WHALE-UST Liquidity 1. Navigate to the [SWAP] page 2. Select [POOL] 3. Select [Withdraw] 4. Enter the amount of WHALE-UST LP tokens you would like to withdraw. Then select [Withdraw] 5. Select [POST] to confirm the transaction 6. Your WHALE and UST will show up in your wallet shortly!","title":"Liquidity Providing"},{"location":"user-guide/Liquidity/#liquidity-providing","text":"Liquidity can be provided for WHALE Tokens https://app.whitewhale.money/swap . The WHALE tokens can be used for governance staking and voting. See STAKING section for details. Note that the liquidity providing rewards are only from transaction fees. There are no token reward incentives for providing WHALE-UST liquidity. Tutorial assumes you have: A Terra Wallet. If not, see the WebApp section. WHALE tokens. If not, see the Swap section.","title":"Liquidity Providing"},{"location":"user-guide/Liquidity/#providing-whale-ust-liquidity","text":"1. Connect Wallet 2. Navigate to the [SWAP] page 3. Select [POOL] 4. Enter equal amounts of WHALE and UST that you would like to provide as liquidity. Then select [PROVIDE] 5. Select [POST] to confirm the transaction","title":"Providing WHALE-UST Liquidity"},{"location":"user-guide/Liquidity/#withdrawing-whale-ust-liquidity","text":"1. Navigate to the [SWAP] page 2. Select [POOL] 3. Select [Withdraw] 4. Enter the amount of WHALE-UST LP tokens you would like to withdraw. Then select [Withdraw] 5. Select [POST] to confirm the transaction 6. Your WHALE and UST will show up in your wallet shortly!","title":"Withdrawing WHALE-UST Liquidity"},{"location":"user-guide/Proposals-Voting/","text":"Governance Proposals & Voting Whale Tokens can be used for governance proposals and voting at https://app.whitewhale.money/gov . The White Whale Governance Staking V1 is a fork of Anchor Protocol's Governance Staking smart contracts. 5k WHALE is needed to create a proposal. If the proposal fails the WHALE tokens are forfeited. Tutorial assumes you have: A Terra Wallet. If not, see the WebApp section. WHALE tokens. If not, see the Swap section. Create a Governance Proposal 1. Navigate to the [GOVERNANCE] page 2. Select [Create Poll] 3. Enter a Title and a description. Then select [Create Poll]","title":"Governance Proposals & Voting"},{"location":"user-guide/Proposals-Voting/#governance-proposals-voting","text":"Whale Tokens can be used for governance proposals and voting at https://app.whitewhale.money/gov . The White Whale Governance Staking V1 is a fork of Anchor Protocol's Governance Staking smart contracts. 5k WHALE is needed to create a proposal. If the proposal fails the WHALE tokens are forfeited. Tutorial assumes you have: A Terra Wallet. If not, see the WebApp section. WHALE tokens. If not, see the Swap section.","title":"Governance Proposals &amp; Voting"},{"location":"user-guide/Proposals-Voting/#create-a-governance-proposal","text":"1. Navigate to the [GOVERNANCE] page 2. Select [Create Poll] 3. Enter a Title and a description. Then select [Create Poll]","title":"Create a Governance Proposal"},{"location":"user-guide/Staking/","text":"Governance Staking V1 WHALE Tokens can be staked at https://app.whitewhale.money/gov . The White Whale Governance Staking V1 is a fork of Anchor Protocol's Governance Staking smart contracts. White Whale periodically distributes WHALE tokens from the none circulating supply to the governance stakers. The White Whale Governance Staking V1 auto-compounds the rewards the rewards for the user. Tutorial assumes you have: A Terra Wallet. If not, see the WebApp section. WHALE tokens. If not, see the Swap section. Staking WHALE 1. Navigate to the [GOVERNANCE] page 2. Select [STAKE] 3. Input the amount of whale you would like to stake then select [Confirm] 4. Select [POST] to confirm transaction in terra station 5. Your WHALE staked will show up here. The rewards will claimed automatically and you will see the number go up over time. Unstaking WHALE 1. Navigate to the [GOVERNANCE] page 2. Select [UNSTAKE] 3. Input the amount of whale you would like to unstake and select [Confirm] 4. Select [POST] to confirm transaction in terra station","title":"Governance Staking V1"},{"location":"user-guide/Staking/#governance-staking-v1","text":"WHALE Tokens can be staked at https://app.whitewhale.money/gov . The White Whale Governance Staking V1 is a fork of Anchor Protocol's Governance Staking smart contracts. White Whale periodically distributes WHALE tokens from the none circulating supply to the governance stakers. The White Whale Governance Staking V1 auto-compounds the rewards the rewards for the user. Tutorial assumes you have: A Terra Wallet. If not, see the WebApp section. WHALE tokens. If not, see the Swap section.","title":"Governance Staking V1"},{"location":"user-guide/Staking/#staking-whale","text":"1. Navigate to the [GOVERNANCE] page 2. Select [STAKE] 3. Input the amount of whale you would like to stake then select [Confirm] 4. Select [POST] to confirm transaction in terra station 5. Your WHALE staked will show up here. The rewards will claimed automatically and you will see the number go up over time.","title":"Staking WHALE"},{"location":"user-guide/Staking/#unstaking-whale","text":"1. Navigate to the [GOVERNANCE] page 2. Select [UNSTAKE] 3. Input the amount of whale you would like to unstake and select [Confirm] 4. Select [POST] to confirm transaction in terra station","title":"Unstaking WHALE"},{"location":"user-guide/Swap/","text":"Swapping Whale Tokens can be swapped at https://app.whitewhale.money/swap . The WHALE tokens can be used for governance staking and voting. See STAKING section for details. Tutorial assumes you have: A Terra Wallet. If not, see the WebApp section. Swapping UST to WHALE 1. Connect Wallet 2. Navigate to the [SWAP] page 3. Enter the amount of UST you want to swap to WHALE. Then select [SWAP] . 4. Select [POST] to confirm transaction 5. Your WHALE tokens will show up in your wallet shortly! Swapping WHALE to UST 1. Navigate to the [SWAP] page 2. Switch to swapping WHALE to UST by hitting the arrow icon. 3. Enter the Amount of WHALE you want to swap to UST then hit [Swap] . 4. Select [POST] to confirm transaction 5. Your UST will show up in your wallet shortly!","title":"Swapping"},{"location":"user-guide/Swap/#swapping","text":"Whale Tokens can be swapped at https://app.whitewhale.money/swap . The WHALE tokens can be used for governance staking and voting. See STAKING section for details. Tutorial assumes you have: A Terra Wallet. If not, see the WebApp section.","title":"Swapping"},{"location":"user-guide/Swap/#swapping-ust-to-whale","text":"1. Connect Wallet 2. Navigate to the [SWAP] page 3. Enter the amount of UST you want to swap to WHALE. Then select [SWAP] . 4. Select [POST] to confirm transaction 5. Your WHALE tokens will show up in your wallet shortly!","title":"Swapping UST to WHALE"},{"location":"user-guide/Swap/#swapping-whale-to-ust","text":"1. Navigate to the [SWAP] page 2. Switch to swapping WHALE to UST by hitting the arrow icon. 3. Enter the Amount of WHALE you want to swap to UST then hit [Swap] . 4. Select [POST] to confirm transaction 5. Your UST will show up in your wallet shortly!","title":"Swapping WHALE to UST"},{"location":"user-guide/Vaults/","text":"Vaults Tokens can be deposited into Vaults at https://app.whitewhale.money/gov . For this tutorial you need a Terra wallet with with UST. a Terra wallet. If not, see the WebApp section. Depositing into Vault 1. Navigate to the [Vaults] page 2. Select [DEPOSIT] 3. Input the amount you would like to deposit then select [DEPOSIT] 4. Select [POST] to confirm transaction in terra station 5. Your deposit will show up here. The rewards are automatically claimed. Withdrawing from Vault 1. Navigate to the [Vaults] page 2. Select [Withdraw] 3. Input the amount of whale you would like to unstake and select [Withdraw] 4. Select [POST] to confirm transaction in terra station","title":"Vaults"},{"location":"user-guide/Vaults/#vaults","text":"Tokens can be deposited into Vaults at https://app.whitewhale.money/gov . For this tutorial you need a Terra wallet with with UST. a Terra wallet. If not, see the WebApp section.","title":"Vaults"},{"location":"user-guide/Vaults/#depositing-into-vault","text":"1. Navigate to the [Vaults] page 2. Select [DEPOSIT] 3. Input the amount you would like to deposit then select [DEPOSIT] 4. Select [POST] to confirm transaction in terra station 5. Your deposit will show up here. The rewards are automatically claimed.","title":"Depositing into Vault"},{"location":"user-guide/Vaults/#withdrawing-from-vault","text":"1. Navigate to the [Vaults] page 2. Select [Withdraw] 3. Input the amount of whale you would like to unstake and select [Withdraw] 4. Select [POST] to confirm transaction in terra station","title":"Withdrawing from Vault"},{"location":"user-guide/WebApp/","text":"WebApp The White Whale WebApp is the official web frontend for interacting with White Whale Protocol on the Terra network. The WebApp can be accessed at https://app.whitewhale.money . The White Whale WebApp offers a graphical user interface for accessing White Whale's core user operations, such as interacting with the vaults, swapping Whale tokens and participating in White Whale governance. White Whale will launch with 3 initial components: The Arb Vaults, Governance and the Treasury. The White Whale web app requires Google Chrome and Station Extension to be installed. Please follow the instructions below to set up your browser to be able to access the WebApp. Terra Station Extension As of March 17th, 2021, Station Extension is only available for Chromium-based web browsers. Station Extension is a Chrome extension that lets users interact with smart contract web frontends with an embedded in-browser wallet. When a user makes an interaction on Anchor WebApp, the WebApp will generate a transaction in the proper format that encodes the user's desired operation. Station Extension will detect and prompt the user to sign and broadcast the transaction to actually execute the operation. Installing Station Extension Run Google Chrome . Station Extension is only available for Chromium-based web browsers. Install Station Extension here . Terra Station should now be visible on the extensions tray. Creating a new wallet 1. Open Station Extension 2. Select New Wallet 3. Set a wallet name and password. Make sure to record the created 24 word seed phrase in a secure storage . Select [Next] to proceed. 4. Confirm the created seed phrase by inputting the correct words. 5. Select [Create a wallet] to finish. Accessing with the Ledger Hardware Wallet Terra Station Extension allows users to connect and sign transactions with their Ledger Nano S or Nano X. To access Ledger from Station Extension, users should: Install Terra application using Ledger Live application. The Developer Mode on Ledger Live application from Settings > Experimental Features must be enabled to install Terra application. The Ledger device must be connected to the user's computer via USB. Station Extension does not support connecting with Bluetooth . To access Ledger from Terra Station Extension, the following steps are required: 1. Connect and unlock your Ledger device 2. Open Terra application from Ledger 3. Select [Access with ledger] on Terra Station Extension menu 4. Once Ledger has been successfully connected with Terra Station Extension, transactions can be signed with Ledger. Recovering an Existing Wallet 1. Select [Recover existing wallet] 2. Enter a new wallet name and password. 3. Enter the 24 word seed phrase of the wallet to recover and select [Next] to finish. Sending Tokens 1. Select [Send] button aligned to the tokens to send. 2. Input the information below and select [Next] : Address of the recipient Amount of tokens to send Memo (optional) Station Extension also support cross-chain token transfers to Ethereum addresses through the Shuttle bridge. 3. Set the denomination and amount of tokens to pay as transaction fees. Enter the password and click [Send] . 4. Station Extension will display the transaction result. Select [Ok] to return to the main page. Obtaining Terra Stablecoins Anchor's money market uses Terra stablecoins as their base denomination. Users must have a balance of Terra stablecoins before they can interact with Anchor. There are several ways to obtain Terra stablecoins: Swapping Luna for Terra stablecoins Purchasing Terra stablecoins from an exchange Swapping Luna for Terra Stablecoins Users can swap Luna or Terra stablecoins such as TerraKRW (KRT), or TerraSDR (SDT) for the desired Terra stablecoin through the Terra blockchain's native swap functionality. The swap feature can be accessed at the \"Swap\" page of Terra Station , the official Terra desktop wallet. 1. Navigate to the \"Swap\" page by clicking it on the sidebar. It should display a page similar to: 2. Select the coin denomination to swap and the coin denomination to receive in the \"Swap coins\" section, found at the bottom of the page. The swap will be conducted based on the current \"Terra exchange rate\". The approximate spread and fee for performing the swap will be shown. The rules for determining the fees are covered in Terra Docs . 3. Click [Next] and sign the transaction to complete the swap. Purchasing Terra Stablecoins From an Exchange Terra stablecoins can be obtained by directly purchasing them from cryptocurrency exchanges. Trading pairs of Terra stablecoins are available at various exchanges. TerraUSD (UST) Trading Pairs Exchange Trading Pairs Bittrex USDT , BTC Kucoin USDT , USDC , BTC , ETH , DOT , ATOM , SNX , AAVE , YFI","title":"WebApp"},{"location":"user-guide/WebApp/#webapp","text":"The White Whale WebApp is the official web frontend for interacting with White Whale Protocol on the Terra network. The WebApp can be accessed at https://app.whitewhale.money . The White Whale WebApp offers a graphical user interface for accessing White Whale's core user operations, such as interacting with the vaults, swapping Whale tokens and participating in White Whale governance. White Whale will launch with 3 initial components: The Arb Vaults, Governance and the Treasury. The White Whale web app requires Google Chrome and Station Extension to be installed. Please follow the instructions below to set up your browser to be able to access the WebApp.","title":"WebApp"},{"location":"user-guide/WebApp/#terra-station-extension","text":"As of March 17th, 2021, Station Extension is only available for Chromium-based web browsers. Station Extension is a Chrome extension that lets users interact with smart contract web frontends with an embedded in-browser wallet. When a user makes an interaction on Anchor WebApp, the WebApp will generate a transaction in the proper format that encodes the user's desired operation. Station Extension will detect and prompt the user to sign and broadcast the transaction to actually execute the operation.","title":"Terra Station Extension"},{"location":"user-guide/WebApp/#installing-station-extension","text":"Run Google Chrome . Station Extension is only available for Chromium-based web browsers. Install Station Extension here . Terra Station should now be visible on the extensions tray.","title":"Installing Station Extension"},{"location":"user-guide/WebApp/#creating-a-new-wallet","text":"1. Open Station Extension 2. Select New Wallet 3. Set a wallet name and password. Make sure to record the created 24 word seed phrase in a secure storage . Select [Next] to proceed. 4. Confirm the created seed phrase by inputting the correct words. 5. Select [Create a wallet] to finish.","title":"Creating a new wallet"},{"location":"user-guide/WebApp/#accessing-with-the-ledger-hardware-wallet","text":"Terra Station Extension allows users to connect and sign transactions with their Ledger Nano S or Nano X. To access Ledger from Station Extension, users should: Install Terra application using Ledger Live application. The Developer Mode on Ledger Live application from Settings > Experimental Features must be enabled to install Terra application. The Ledger device must be connected to the user's computer via USB. Station Extension does not support connecting with Bluetooth . To access Ledger from Terra Station Extension, the following steps are required: 1. Connect and unlock your Ledger device 2. Open Terra application from Ledger 3. Select [Access with ledger] on Terra Station Extension menu 4. Once Ledger has been successfully connected with Terra Station Extension, transactions can be signed with Ledger.","title":"Accessing with the Ledger Hardware Wallet"},{"location":"user-guide/WebApp/#recovering-an-existing-wallet","text":"1. Select [Recover existing wallet] 2. Enter a new wallet name and password. 3. Enter the 24 word seed phrase of the wallet to recover and select [Next] to finish.","title":"Recovering an Existing Wallet"},{"location":"user-guide/WebApp/#sending-tokens","text":"1. Select [Send] button aligned to the tokens to send. 2. Input the information below and select [Next] : Address of the recipient Amount of tokens to send Memo (optional) Station Extension also support cross-chain token transfers to Ethereum addresses through the Shuttle bridge. 3. Set the denomination and amount of tokens to pay as transaction fees. Enter the password and click [Send] . 4. Station Extension will display the transaction result. Select [Ok] to return to the main page.","title":"Sending Tokens"},{"location":"user-guide/WebApp/#obtaining-terra-stablecoins","text":"Anchor's money market uses Terra stablecoins as their base denomination. Users must have a balance of Terra stablecoins before they can interact with Anchor. There are several ways to obtain Terra stablecoins: Swapping Luna for Terra stablecoins Purchasing Terra stablecoins from an exchange","title":"Obtaining Terra Stablecoins"},{"location":"user-guide/WebApp/#swapping-luna-for-terra-stablecoins","text":"Users can swap Luna or Terra stablecoins such as TerraKRW (KRT), or TerraSDR (SDT) for the desired Terra stablecoin through the Terra blockchain's native swap functionality. The swap feature can be accessed at the \"Swap\" page of Terra Station , the official Terra desktop wallet. 1. Navigate to the \"Swap\" page by clicking it on the sidebar. It should display a page similar to: 2. Select the coin denomination to swap and the coin denomination to receive in the \"Swap coins\" section, found at the bottom of the page. The swap will be conducted based on the current \"Terra exchange rate\". The approximate spread and fee for performing the swap will be shown. The rules for determining the fees are covered in Terra Docs . 3. Click [Next] and sign the transaction to complete the swap.","title":"Swapping Luna for Terra Stablecoins"},{"location":"user-guide/WebApp/#purchasing-terra-stablecoins-from-an-exchange","text":"Terra stablecoins can be obtained by directly purchasing them from cryptocurrency exchanges. Trading pairs of Terra stablecoins are available at various exchanges.","title":"Purchasing Terra Stablecoins From an Exchange"},{"location":"user-guide/WebApp/#terrausd-ust-trading-pairs","text":"Exchange Trading Pairs Bittrex USDT , BTC Kucoin USDT , USDC , BTC , ETH , DOT , ATOM , SNX , AAVE , YFI","title":"TerraUSD (UST) Trading Pairs"}]}